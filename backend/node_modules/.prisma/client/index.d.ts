
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * --------------------------------------------------------------------------
 * üßë‚Äçüíº EXISTING USER + ROLE MODELS
 * --------------------------------------------------------------------------
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model book_details
 * --------------------------------------------------------------------------
 * üìö EXISTING BOOKS & RELATED MODELS
 * --------------------------------------------------------------------------
 */
export type book_details = $Result.DefaultSelection<Prisma.$book_detailsPayload>
/**
 * Model books
 * 
 */
export type books = $Result.DefaultSelection<Prisma.$booksPayload>
/**
 * Model cart_items
 * 
 */
export type cart_items = $Result.DefaultSelection<Prisma.$cart_itemsPayload>
/**
 * Model category_lookup
 * 
 */
export type category_lookup = $Result.DefaultSelection<Prisma.$category_lookupPayload>
/**
 * Model orders
 * 
 */
export type orders = $Result.DefaultSelection<Prisma.$ordersPayload>
/**
 * Model parents
 * 
 */
export type parents = $Result.DefaultSelection<Prisma.$parentsPayload>
/**
 * Model ChildUser
 * --------------------------------------------------------------------------
 * üë®‚Äçüë©‚Äçüëß NEW CHILD & ASSIGNMENT MODELS
 * --------------------------------------------------------------------------
 */
export type ChildUser = $Result.DefaultSelection<Prisma.$ChildUserPayload>
/**
 * Model ChildAssignment
 * 
 */
export type ChildAssignment = $Result.DefaultSelection<Prisma.$ChildAssignmentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  PARENT: 'PARENT',
  STUDENT: 'STUDENT',
  SUPPLIER: 'SUPPLIER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const AssignmentStatus: {
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  REVOKED: 'REVOKED'
};

export type AssignmentStatus = (typeof AssignmentStatus)[keyof typeof AssignmentStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type AssignmentStatus = $Enums.AssignmentStatus

export const AssignmentStatus: typeof $Enums.AssignmentStatus

/**
 * ##  Prisma Client  ≤À¢
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client  ≤À¢
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_details`: Exposes CRUD operations for the **book_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_details
    * const book_details = await prisma.book_details.findMany()
    * ```
    */
  get book_details(): Prisma.book_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.books`: Exposes CRUD operations for the **books** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books
    * const books = await prisma.books.findMany()
    * ```
    */
  get books(): Prisma.booksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart_items`: Exposes CRUD operations for the **cart_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cart_items
    * const cart_items = await prisma.cart_items.findMany()
    * ```
    */
  get cart_items(): Prisma.cart_itemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category_lookup`: Exposes CRUD operations for the **category_lookup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Category_lookups
    * const category_lookups = await prisma.category_lookup.findMany()
    * ```
    */
  get category_lookup(): Prisma.category_lookupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.ordersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parents`: Exposes CRUD operations for the **parents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parents.findMany()
    * ```
    */
  get parents(): Prisma.parentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.childUser`: Exposes CRUD operations for the **ChildUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChildUsers
    * const childUsers = await prisma.childUser.findMany()
    * ```
    */
  get childUser(): Prisma.ChildUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.childAssignment`: Exposes CRUD operations for the **ChildAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChildAssignments
    * const childAssignments = await prisma.childAssignment.findMany()
    * ```
    */
  get childAssignment(): Prisma.ChildAssignmentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    book_details: 'book_details',
    books: 'books',
    cart_items: 'cart_items',
    category_lookup: 'category_lookup',
    orders: 'orders',
    parents: 'parents',
    ChildUser: 'ChildUser',
    ChildAssignment: 'ChildAssignment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "book_details" | "books" | "cart_items" | "category_lookup" | "orders" | "parents" | "childUser" | "childAssignment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      book_details: {
        payload: Prisma.$book_detailsPayload<ExtArgs>
        fields: Prisma.book_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.book_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.book_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_detailsPayload>
          }
          findFirst: {
            args: Prisma.book_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.book_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_detailsPayload>
          }
          findMany: {
            args: Prisma.book_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_detailsPayload>[]
          }
          create: {
            args: Prisma.book_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_detailsPayload>
          }
          createMany: {
            args: Prisma.book_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.book_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_detailsPayload>[]
          }
          delete: {
            args: Prisma.book_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_detailsPayload>
          }
          update: {
            args: Prisma.book_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_detailsPayload>
          }
          deleteMany: {
            args: Prisma.book_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.book_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.book_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_detailsPayload>[]
          }
          upsert: {
            args: Prisma.book_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_detailsPayload>
          }
          aggregate: {
            args: Prisma.Book_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_details>
          }
          groupBy: {
            args: Prisma.book_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.book_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Book_detailsCountAggregateOutputType> | number
          }
        }
      }
      books: {
        payload: Prisma.$booksPayload<ExtArgs>
        fields: Prisma.booksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.booksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.booksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booksPayload>
          }
          findFirst: {
            args: Prisma.booksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.booksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booksPayload>
          }
          findMany: {
            args: Prisma.booksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booksPayload>[]
          }
          create: {
            args: Prisma.booksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booksPayload>
          }
          createMany: {
            args: Prisma.booksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.booksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booksPayload>[]
          }
          delete: {
            args: Prisma.booksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booksPayload>
          }
          update: {
            args: Prisma.booksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booksPayload>
          }
          deleteMany: {
            args: Prisma.booksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.booksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.booksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booksPayload>[]
          }
          upsert: {
            args: Prisma.booksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booksPayload>
          }
          aggregate: {
            args: Prisma.BooksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooks>
          }
          groupBy: {
            args: Prisma.booksGroupByArgs<ExtArgs>
            result: $Utils.Optional<BooksGroupByOutputType>[]
          }
          count: {
            args: Prisma.booksCountArgs<ExtArgs>
            result: $Utils.Optional<BooksCountAggregateOutputType> | number
          }
        }
      }
      cart_items: {
        payload: Prisma.$cart_itemsPayload<ExtArgs>
        fields: Prisma.cart_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cart_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cart_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cart_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cart_itemsPayload>
          }
          findFirst: {
            args: Prisma.cart_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cart_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cart_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cart_itemsPayload>
          }
          findMany: {
            args: Prisma.cart_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cart_itemsPayload>[]
          }
          create: {
            args: Prisma.cart_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cart_itemsPayload>
          }
          createMany: {
            args: Prisma.cart_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cart_itemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cart_itemsPayload>[]
          }
          delete: {
            args: Prisma.cart_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cart_itemsPayload>
          }
          update: {
            args: Prisma.cart_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cart_itemsPayload>
          }
          deleteMany: {
            args: Prisma.cart_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cart_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cart_itemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cart_itemsPayload>[]
          }
          upsert: {
            args: Prisma.cart_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cart_itemsPayload>
          }
          aggregate: {
            args: Prisma.Cart_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart_items>
          }
          groupBy: {
            args: Prisma.cart_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cart_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.cart_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Cart_itemsCountAggregateOutputType> | number
          }
        }
      }
      category_lookup: {
        payload: Prisma.$category_lookupPayload<ExtArgs>
        fields: Prisma.category_lookupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.category_lookupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_lookupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.category_lookupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_lookupPayload>
          }
          findFirst: {
            args: Prisma.category_lookupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_lookupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.category_lookupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_lookupPayload>
          }
          findMany: {
            args: Prisma.category_lookupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_lookupPayload>[]
          }
          create: {
            args: Prisma.category_lookupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_lookupPayload>
          }
          createMany: {
            args: Prisma.category_lookupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.category_lookupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_lookupPayload>[]
          }
          delete: {
            args: Prisma.category_lookupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_lookupPayload>
          }
          update: {
            args: Prisma.category_lookupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_lookupPayload>
          }
          deleteMany: {
            args: Prisma.category_lookupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.category_lookupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.category_lookupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_lookupPayload>[]
          }
          upsert: {
            args: Prisma.category_lookupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_lookupPayload>
          }
          aggregate: {
            args: Prisma.Category_lookupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory_lookup>
          }
          groupBy: {
            args: Prisma.category_lookupGroupByArgs<ExtArgs>
            result: $Utils.Optional<Category_lookupGroupByOutputType>[]
          }
          count: {
            args: Prisma.category_lookupCountArgs<ExtArgs>
            result: $Utils.Optional<Category_lookupCountAggregateOutputType> | number
          }
        }
      }
      orders: {
        payload: Prisma.$ordersPayload<ExtArgs>
        fields: Prisma.ordersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ordersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ordersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          findFirst: {
            args: Prisma.ordersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ordersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          findMany: {
            args: Prisma.ordersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          create: {
            args: Prisma.ordersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          createMany: {
            args: Prisma.ordersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ordersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          delete: {
            args: Prisma.ordersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          update: {
            args: Prisma.ordersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          deleteMany: {
            args: Prisma.ordersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ordersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ordersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          upsert: {
            args: Prisma.ordersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          aggregate: {
            args: Prisma.OrdersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrders>
          }
          groupBy: {
            args: Prisma.ordersGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ordersCountArgs<ExtArgs>
            result: $Utils.Optional<OrdersCountAggregateOutputType> | number
          }
        }
      }
      parents: {
        payload: Prisma.$parentsPayload<ExtArgs>
        fields: Prisma.parentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.parentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.parentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          findFirst: {
            args: Prisma.parentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.parentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          findMany: {
            args: Prisma.parentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>[]
          }
          create: {
            args: Prisma.parentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          createMany: {
            args: Prisma.parentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.parentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>[]
          }
          delete: {
            args: Prisma.parentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          update: {
            args: Prisma.parentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          deleteMany: {
            args: Prisma.parentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.parentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.parentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>[]
          }
          upsert: {
            args: Prisma.parentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          aggregate: {
            args: Prisma.ParentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParents>
          }
          groupBy: {
            args: Prisma.parentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.parentsCountArgs<ExtArgs>
            result: $Utils.Optional<ParentsCountAggregateOutputType> | number
          }
        }
      }
      ChildUser: {
        payload: Prisma.$ChildUserPayload<ExtArgs>
        fields: Prisma.ChildUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChildUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChildUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildUserPayload>
          }
          findFirst: {
            args: Prisma.ChildUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChildUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildUserPayload>
          }
          findMany: {
            args: Prisma.ChildUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildUserPayload>[]
          }
          create: {
            args: Prisma.ChildUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildUserPayload>
          }
          createMany: {
            args: Prisma.ChildUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChildUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildUserPayload>[]
          }
          delete: {
            args: Prisma.ChildUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildUserPayload>
          }
          update: {
            args: Prisma.ChildUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildUserPayload>
          }
          deleteMany: {
            args: Prisma.ChildUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChildUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChildUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildUserPayload>[]
          }
          upsert: {
            args: Prisma.ChildUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildUserPayload>
          }
          aggregate: {
            args: Prisma.ChildUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChildUser>
          }
          groupBy: {
            args: Prisma.ChildUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChildUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChildUserCountArgs<ExtArgs>
            result: $Utils.Optional<ChildUserCountAggregateOutputType> | number
          }
        }
      }
      ChildAssignment: {
        payload: Prisma.$ChildAssignmentPayload<ExtArgs>
        fields: Prisma.ChildAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChildAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChildAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ChildAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChildAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildAssignmentPayload>
          }
          findMany: {
            args: Prisma.ChildAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildAssignmentPayload>[]
          }
          create: {
            args: Prisma.ChildAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildAssignmentPayload>
          }
          createMany: {
            args: Prisma.ChildAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChildAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ChildAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildAssignmentPayload>
          }
          update: {
            args: Prisma.ChildAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ChildAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChildAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChildAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.ChildAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ChildAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChildAssignment>
          }
          groupBy: {
            args: Prisma.ChildAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChildAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChildAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ChildAssignmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    book_details?: book_detailsOmit
    books?: booksOmit
    cart_items?: cart_itemsOmit
    category_lookup?: category_lookupOmit
    orders?: ordersOmit
    parents?: parentsOmit
    childUser?: ChildUserOmit
    childAssignment?: ChildAssignmentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BooksCountOutputType
   */

  export type BooksCountOutputType = {
    cart_items: number
  }

  export type BooksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart_items?: boolean | BooksCountOutputTypeCountCart_itemsArgs
  }

  // Custom InputTypes
  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BooksCountOutputType
     */
    select?: BooksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BooksCountOutputType without action
   */
  export type BooksCountOutputTypeCountCart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cart_itemsWhereInput
  }


  /**
   * Count Type Category_lookupCountOutputType
   */

  export type Category_lookupCountOutputType = {
    books: number
  }

  export type Category_lookupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | Category_lookupCountOutputTypeCountBooksArgs
  }

  // Custom InputTypes
  /**
   * Category_lookupCountOutputType without action
   */
  export type Category_lookupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category_lookupCountOutputType
     */
    select?: Category_lookupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Category_lookupCountOutputType without action
   */
  export type Category_lookupCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booksWhereInput
  }


  /**
   * Count Type ChildUserCountOutputType
   */

  export type ChildUserCountOutputType = {
    assignments: number
  }

  export type ChildUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | ChildUserCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * ChildUserCountOutputType without action
   */
  export type ChildUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUserCountOutputType
     */
    select?: ChildUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChildUserCountOutputType without action
   */
  export type ChildUserCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildAssignmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    subscriptionStatus: string | null
    trialEndDate: Date | null
    trialStartDate: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    subscriptionStatus: string | null
    trialEndDate: Date | null
    trialStartDate: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    subscriptionStatus: number
    trialEndDate: number
    trialStartDate: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    subscriptionStatus?: true
    trialEndDate?: true
    trialStartDate?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    subscriptionStatus?: true
    trialEndDate?: true
    trialStartDate?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    subscriptionStatus?: true
    trialEndDate?: true
    trialStartDate?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    subscriptionStatus: string | null
    trialEndDate: Date | null
    trialStartDate: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptionStatus?: boolean
    trialEndDate?: boolean
    trialStartDate?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptionStatus?: boolean
    trialEndDate?: boolean
    trialStartDate?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptionStatus?: boolean
    trialEndDate?: boolean
    trialStartDate?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptionStatus?: boolean
    trialEndDate?: boolean
    trialStartDate?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "createdAt" | "updatedAt" | "subscriptionStatus" | "trialEndDate" | "trialStartDate", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
      subscriptionStatus: string | null
      trialEndDate: Date | null
      trialStartDate: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly subscriptionStatus: FieldRef<"User", 'String'>
    readonly trialEndDate: FieldRef<"User", 'DateTime'>
    readonly trialStartDate: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model book_details
   */

  export type AggregateBook_details = {
    _count: Book_detailsCountAggregateOutputType | null
    _avg: Book_detailsAvgAggregateOutputType | null
    _sum: Book_detailsSumAggregateOutputType | null
    _min: Book_detailsMinAggregateOutputType | null
    _max: Book_detailsMaxAggregateOutputType | null
  }

  export type Book_detailsAvgAggregateOutputType = {
    id: number | null
  }

  export type Book_detailsSumAggregateOutputType = {
    id: number | null
  }

  export type Book_detailsMinAggregateOutputType = {
    id: number | null
    isbn: string | null
    overview: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Book_detailsMaxAggregateOutputType = {
    id: number | null
    isbn: string | null
    overview: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Book_detailsCountAggregateOutputType = {
    id: number
    isbn: number
    overview: number
    features: number
    contents: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Book_detailsAvgAggregateInputType = {
    id?: true
  }

  export type Book_detailsSumAggregateInputType = {
    id?: true
  }

  export type Book_detailsMinAggregateInputType = {
    id?: true
    isbn?: true
    overview?: true
    created_at?: true
    updated_at?: true
  }

  export type Book_detailsMaxAggregateInputType = {
    id?: true
    isbn?: true
    overview?: true
    created_at?: true
    updated_at?: true
  }

  export type Book_detailsCountAggregateInputType = {
    id?: true
    isbn?: true
    overview?: true
    features?: true
    contents?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Book_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_details to aggregate.
     */
    where?: book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_details to fetch.
     */
    orderBy?: book_detailsOrderByWithRelationInput | book_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` book_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_details
    **/
    _count?: true | Book_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Book_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Book_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_detailsMaxAggregateInputType
  }

  export type GetBook_detailsAggregateType<T extends Book_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_details[P]>
      : GetScalarType<T[P], AggregateBook_details[P]>
  }




  export type book_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_detailsWhereInput
    orderBy?: book_detailsOrderByWithAggregationInput | book_detailsOrderByWithAggregationInput[]
    by: Book_detailsScalarFieldEnum[] | Book_detailsScalarFieldEnum
    having?: book_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_detailsCountAggregateInputType | true
    _avg?: Book_detailsAvgAggregateInputType
    _sum?: Book_detailsSumAggregateInputType
    _min?: Book_detailsMinAggregateInputType
    _max?: Book_detailsMaxAggregateInputType
  }

  export type Book_detailsGroupByOutputType = {
    id: number
    isbn: string | null
    overview: string | null
    features: string[]
    contents: string[]
    created_at: Date | null
    updated_at: Date | null
    _count: Book_detailsCountAggregateOutputType | null
    _avg: Book_detailsAvgAggregateOutputType | null
    _sum: Book_detailsSumAggregateOutputType | null
    _min: Book_detailsMinAggregateOutputType | null
    _max: Book_detailsMaxAggregateOutputType | null
  }

  type GetBook_detailsGroupByPayload<T extends book_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Book_detailsGroupByOutputType[P]>
        }
      >
    >


  export type book_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isbn?: boolean
    overview?: boolean
    features?: boolean
    contents?: boolean
    created_at?: boolean
    updated_at?: boolean
    books?: boolean | book_details$booksArgs<ExtArgs>
  }, ExtArgs["result"]["book_details"]>

  export type book_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isbn?: boolean
    overview?: boolean
    features?: boolean
    contents?: boolean
    created_at?: boolean
    updated_at?: boolean
    books?: boolean | book_details$booksArgs<ExtArgs>
  }, ExtArgs["result"]["book_details"]>

  export type book_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isbn?: boolean
    overview?: boolean
    features?: boolean
    contents?: boolean
    created_at?: boolean
    updated_at?: boolean
    books?: boolean | book_details$booksArgs<ExtArgs>
  }, ExtArgs["result"]["book_details"]>

  export type book_detailsSelectScalar = {
    id?: boolean
    isbn?: boolean
    overview?: boolean
    features?: boolean
    contents?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type book_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isbn" | "overview" | "features" | "contents" | "created_at" | "updated_at", ExtArgs["result"]["book_details"]>
  export type book_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | book_details$booksArgs<ExtArgs>
  }
  export type book_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | book_details$booksArgs<ExtArgs>
  }
  export type book_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | book_details$booksArgs<ExtArgs>
  }

  export type $book_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "book_details"
    objects: {
      books: Prisma.$booksPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isbn: string | null
      overview: string | null
      features: string[]
      contents: string[]
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["book_details"]>
    composites: {}
  }

  type book_detailsGetPayload<S extends boolean | null | undefined | book_detailsDefaultArgs> = $Result.GetResult<Prisma.$book_detailsPayload, S>

  type book_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<book_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_detailsCountAggregateInputType | true
    }

  export interface book_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['book_details'], meta: { name: 'book_details' } }
    /**
     * Find zero or one Book_details that matches the filter.
     * @param {book_detailsFindUniqueArgs} args - Arguments to find a Book_details
     * @example
     * // Get one Book_details
     * const book_details = await prisma.book_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends book_detailsFindUniqueArgs>(args: SelectSubset<T, book_detailsFindUniqueArgs<ExtArgs>>): Prisma__book_detailsClient<$Result.GetResult<Prisma.$book_detailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {book_detailsFindUniqueOrThrowArgs} args - Arguments to find a Book_details
     * @example
     * // Get one Book_details
     * const book_details = await prisma.book_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends book_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, book_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__book_detailsClient<$Result.GetResult<Prisma.$book_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_detailsFindFirstArgs} args - Arguments to find a Book_details
     * @example
     * // Get one Book_details
     * const book_details = await prisma.book_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends book_detailsFindFirstArgs>(args?: SelectSubset<T, book_detailsFindFirstArgs<ExtArgs>>): Prisma__book_detailsClient<$Result.GetResult<Prisma.$book_detailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_detailsFindFirstOrThrowArgs} args - Arguments to find a Book_details
     * @example
     * // Get one Book_details
     * const book_details = await prisma.book_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends book_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, book_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__book_detailsClient<$Result.GetResult<Prisma.$book_detailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_details
     * const book_details = await prisma.book_details.findMany()
     * 
     * // Get first 10 Book_details
     * const book_details = await prisma.book_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const book_detailsWithIdOnly = await prisma.book_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends book_detailsFindManyArgs>(args?: SelectSubset<T, book_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_details.
     * @param {book_detailsCreateArgs} args - Arguments to create a Book_details.
     * @example
     * // Create one Book_details
     * const Book_details = await prisma.book_details.create({
     *   data: {
     *     // ... data to create a Book_details
     *   }
     * })
     * 
     */
    create<T extends book_detailsCreateArgs>(args: SelectSubset<T, book_detailsCreateArgs<ExtArgs>>): Prisma__book_detailsClient<$Result.GetResult<Prisma.$book_detailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_details.
     * @param {book_detailsCreateManyArgs} args - Arguments to create many Book_details.
     * @example
     * // Create many Book_details
     * const book_details = await prisma.book_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends book_detailsCreateManyArgs>(args?: SelectSubset<T, book_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Book_details and returns the data saved in the database.
     * @param {book_detailsCreateManyAndReturnArgs} args - Arguments to create many Book_details.
     * @example
     * // Create many Book_details
     * const book_details = await prisma.book_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Book_details and only return the `id`
     * const book_detailsWithIdOnly = await prisma.book_details.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends book_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, book_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_detailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book_details.
     * @param {book_detailsDeleteArgs} args - Arguments to delete one Book_details.
     * @example
     * // Delete one Book_details
     * const Book_details = await prisma.book_details.delete({
     *   where: {
     *     // ... filter to delete one Book_details
     *   }
     * })
     * 
     */
    delete<T extends book_detailsDeleteArgs>(args: SelectSubset<T, book_detailsDeleteArgs<ExtArgs>>): Prisma__book_detailsClient<$Result.GetResult<Prisma.$book_detailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_details.
     * @param {book_detailsUpdateArgs} args - Arguments to update one Book_details.
     * @example
     * // Update one Book_details
     * const book_details = await prisma.book_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends book_detailsUpdateArgs>(args: SelectSubset<T, book_detailsUpdateArgs<ExtArgs>>): Prisma__book_detailsClient<$Result.GetResult<Prisma.$book_detailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_details.
     * @param {book_detailsDeleteManyArgs} args - Arguments to filter Book_details to delete.
     * @example
     * // Delete a few Book_details
     * const { count } = await prisma.book_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends book_detailsDeleteManyArgs>(args?: SelectSubset<T, book_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_details
     * const book_details = await prisma.book_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends book_detailsUpdateManyArgs>(args: SelectSubset<T, book_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_details and returns the data updated in the database.
     * @param {book_detailsUpdateManyAndReturnArgs} args - Arguments to update many Book_details.
     * @example
     * // Update many Book_details
     * const book_details = await prisma.book_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Book_details and only return the `id`
     * const book_detailsWithIdOnly = await prisma.book_details.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends book_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, book_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_detailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book_details.
     * @param {book_detailsUpsertArgs} args - Arguments to update or create a Book_details.
     * @example
     * // Update or create a Book_details
     * const book_details = await prisma.book_details.upsert({
     *   create: {
     *     // ... data to create a Book_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_details we want to update
     *   }
     * })
     */
    upsert<T extends book_detailsUpsertArgs>(args: SelectSubset<T, book_detailsUpsertArgs<ExtArgs>>): Prisma__book_detailsClient<$Result.GetResult<Prisma.$book_detailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_detailsCountArgs} args - Arguments to filter Book_details to count.
     * @example
     * // Count the number of Book_details
     * const count = await prisma.book_details.count({
     *   where: {
     *     // ... the filter for the Book_details we want to count
     *   }
     * })
    **/
    count<T extends book_detailsCountArgs>(
      args?: Subset<T, book_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_detailsAggregateArgs>(args: Subset<T, Book_detailsAggregateArgs>): Prisma.PrismaPromise<GetBook_detailsAggregateType<T>>

    /**
     * Group by Book_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends book_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: book_detailsGroupByArgs['orderBy'] }
        : { orderBy?: book_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, book_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the book_details model
   */
  readonly fields: book_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for book_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__book_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends book_details$booksArgs<ExtArgs> = {}>(args?: Subset<T, book_details$booksArgs<ExtArgs>>): Prisma__booksClient<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the book_details model
   */
  interface book_detailsFieldRefs {
    readonly id: FieldRef<"book_details", 'Int'>
    readonly isbn: FieldRef<"book_details", 'String'>
    readonly overview: FieldRef<"book_details", 'String'>
    readonly features: FieldRef<"book_details", 'String[]'>
    readonly contents: FieldRef<"book_details", 'String[]'>
    readonly created_at: FieldRef<"book_details", 'DateTime'>
    readonly updated_at: FieldRef<"book_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * book_details findUnique
   */
  export type book_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsInclude<ExtArgs> | null
    /**
     * Filter, which book_details to fetch.
     */
    where: book_detailsWhereUniqueInput
  }

  /**
   * book_details findUniqueOrThrow
   */
  export type book_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsInclude<ExtArgs> | null
    /**
     * Filter, which book_details to fetch.
     */
    where: book_detailsWhereUniqueInput
  }

  /**
   * book_details findFirst
   */
  export type book_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsInclude<ExtArgs> | null
    /**
     * Filter, which book_details to fetch.
     */
    where?: book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_details to fetch.
     */
    orderBy?: book_detailsOrderByWithRelationInput | book_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_details.
     */
    cursor?: book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` book_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_details.
     */
    distinct?: Book_detailsScalarFieldEnum | Book_detailsScalarFieldEnum[]
  }

  /**
   * book_details findFirstOrThrow
   */
  export type book_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsInclude<ExtArgs> | null
    /**
     * Filter, which book_details to fetch.
     */
    where?: book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_details to fetch.
     */
    orderBy?: book_detailsOrderByWithRelationInput | book_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_details.
     */
    cursor?: book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` book_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_details.
     */
    distinct?: Book_detailsScalarFieldEnum | Book_detailsScalarFieldEnum[]
  }

  /**
   * book_details findMany
   */
  export type book_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsInclude<ExtArgs> | null
    /**
     * Filter, which book_details to fetch.
     */
    where?: book_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_details to fetch.
     */
    orderBy?: book_detailsOrderByWithRelationInput | book_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_details.
     */
    cursor?: book_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` book_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_details.
     */
    skip?: number
    distinct?: Book_detailsScalarFieldEnum | Book_detailsScalarFieldEnum[]
  }

  /**
   * book_details create
   */
  export type book_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a book_details.
     */
    data?: XOR<book_detailsCreateInput, book_detailsUncheckedCreateInput>
  }

  /**
   * book_details createMany
   */
  export type book_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many book_details.
     */
    data: book_detailsCreateManyInput | book_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * book_details createManyAndReturn
   */
  export type book_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many book_details.
     */
    data: book_detailsCreateManyInput | book_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * book_details update
   */
  export type book_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a book_details.
     */
    data: XOR<book_detailsUpdateInput, book_detailsUncheckedUpdateInput>
    /**
     * Choose, which book_details to update.
     */
    where: book_detailsWhereUniqueInput
  }

  /**
   * book_details updateMany
   */
  export type book_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update book_details.
     */
    data: XOR<book_detailsUpdateManyMutationInput, book_detailsUncheckedUpdateManyInput>
    /**
     * Filter which book_details to update
     */
    where?: book_detailsWhereInput
    /**
     * Limit how many book_details to update.
     */
    limit?: number
  }

  /**
   * book_details updateManyAndReturn
   */
  export type book_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * The data used to update book_details.
     */
    data: XOR<book_detailsUpdateManyMutationInput, book_detailsUncheckedUpdateManyInput>
    /**
     * Filter which book_details to update
     */
    where?: book_detailsWhereInput
    /**
     * Limit how many book_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * book_details upsert
   */
  export type book_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the book_details to update in case it exists.
     */
    where: book_detailsWhereUniqueInput
    /**
     * In case the book_details found by the `where` argument doesn't exist, create a new book_details with this data.
     */
    create: XOR<book_detailsCreateInput, book_detailsUncheckedCreateInput>
    /**
     * In case the book_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<book_detailsUpdateInput, book_detailsUncheckedUpdateInput>
  }

  /**
   * book_details delete
   */
  export type book_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsInclude<ExtArgs> | null
    /**
     * Filter which book_details to delete.
     */
    where: book_detailsWhereUniqueInput
  }

  /**
   * book_details deleteMany
   */
  export type book_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_details to delete
     */
    where?: book_detailsWhereInput
    /**
     * Limit how many book_details to delete.
     */
    limit?: number
  }

  /**
   * book_details.books
   */
  export type book_details$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksInclude<ExtArgs> | null
    where?: booksWhereInput
  }

  /**
   * book_details without action
   */
  export type book_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsInclude<ExtArgs> | null
  }


  /**
   * Model books
   */

  export type AggregateBooks = {
    _count: BooksCountAggregateOutputType | null
    _avg: BooksAvgAggregateOutputType | null
    _sum: BooksSumAggregateOutputType | null
    _min: BooksMinAggregateOutputType | null
    _max: BooksMaxAggregateOutputType | null
  }

  export type BooksAvgAggregateOutputType = {
    id: number | null
    markup: number | null
    price: number | null
    price_gbp: Decimal | null
    price_ugx: Decimal | null
    category_id: number | null
  }

  export type BooksSumAggregateOutputType = {
    id: number | null
    markup: number | null
    price: number | null
    price_gbp: Decimal | null
    price_ugx: Decimal | null
    category_id: number | null
  }

  export type BooksMinAggregateOutputType = {
    id: number | null
    title: string | null
    authors: string | null
    subject: string | null
    code: string | null
    edition: string | null
    isbn: string | null
    markup: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cover_url: string | null
    category: string | null
    year: string | null
    type: string | null
    price_gbp: Decimal | null
    price_ugx: Decimal | null
    level: string | null
    published_date: Date | null
    format: string | null
    has_digital_access: boolean | null
    publisher: string | null
    grade_year: string | null
    category_id: number | null
    author: string | null
  }

  export type BooksMaxAggregateOutputType = {
    id: number | null
    title: string | null
    authors: string | null
    subject: string | null
    code: string | null
    edition: string | null
    isbn: string | null
    markup: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cover_url: string | null
    category: string | null
    year: string | null
    type: string | null
    price_gbp: Decimal | null
    price_ugx: Decimal | null
    level: string | null
    published_date: Date | null
    format: string | null
    has_digital_access: boolean | null
    publisher: string | null
    grade_year: string | null
    category_id: number | null
    author: string | null
  }

  export type BooksCountAggregateOutputType = {
    id: number
    title: number
    authors: number
    subject: number
    code: number
    edition: number
    isbn: number
    markup: number
    price: number
    createdAt: number
    updatedAt: number
    cover_url: number
    category: number
    year: number
    type: number
    price_gbp: number
    price_ugx: number
    level: number
    published_date: number
    format: number
    has_digital_access: number
    publisher: number
    grade_year: number
    category_id: number
    author: number
    _all: number
  }


  export type BooksAvgAggregateInputType = {
    id?: true
    markup?: true
    price?: true
    price_gbp?: true
    price_ugx?: true
    category_id?: true
  }

  export type BooksSumAggregateInputType = {
    id?: true
    markup?: true
    price?: true
    price_gbp?: true
    price_ugx?: true
    category_id?: true
  }

  export type BooksMinAggregateInputType = {
    id?: true
    title?: true
    authors?: true
    subject?: true
    code?: true
    edition?: true
    isbn?: true
    markup?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    cover_url?: true
    category?: true
    year?: true
    type?: true
    price_gbp?: true
    price_ugx?: true
    level?: true
    published_date?: true
    format?: true
    has_digital_access?: true
    publisher?: true
    grade_year?: true
    category_id?: true
    author?: true
  }

  export type BooksMaxAggregateInputType = {
    id?: true
    title?: true
    authors?: true
    subject?: true
    code?: true
    edition?: true
    isbn?: true
    markup?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    cover_url?: true
    category?: true
    year?: true
    type?: true
    price_gbp?: true
    price_ugx?: true
    level?: true
    published_date?: true
    format?: true
    has_digital_access?: true
    publisher?: true
    grade_year?: true
    category_id?: true
    author?: true
  }

  export type BooksCountAggregateInputType = {
    id?: true
    title?: true
    authors?: true
    subject?: true
    code?: true
    edition?: true
    isbn?: true
    markup?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    cover_url?: true
    category?: true
    year?: true
    type?: true
    price_gbp?: true
    price_ugx?: true
    level?: true
    published_date?: true
    format?: true
    has_digital_access?: true
    publisher?: true
    grade_year?: true
    category_id?: true
    author?: true
    _all?: true
  }

  export type BooksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which books to aggregate.
     */
    where?: booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books to fetch.
     */
    orderBy?: booksOrderByWithRelationInput | booksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned books
    **/
    _count?: true | BooksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BooksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BooksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BooksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BooksMaxAggregateInputType
  }

  export type GetBooksAggregateType<T extends BooksAggregateArgs> = {
        [P in keyof T & keyof AggregateBooks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooks[P]>
      : GetScalarType<T[P], AggregateBooks[P]>
  }




  export type booksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booksWhereInput
    orderBy?: booksOrderByWithAggregationInput | booksOrderByWithAggregationInput[]
    by: BooksScalarFieldEnum[] | BooksScalarFieldEnum
    having?: booksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BooksCountAggregateInputType | true
    _avg?: BooksAvgAggregateInputType
    _sum?: BooksSumAggregateInputType
    _min?: BooksMinAggregateInputType
    _max?: BooksMaxAggregateInputType
  }

  export type BooksGroupByOutputType = {
    id: number
    title: string
    authors: string | null
    subject: string | null
    code: string | null
    edition: string | null
    isbn: string | null
    markup: number | null
    price: number | null
    createdAt: Date
    updatedAt: Date | null
    cover_url: string | null
    category: string | null
    year: string | null
    type: string | null
    price_gbp: Decimal | null
    price_ugx: Decimal | null
    level: string | null
    published_date: Date | null
    format: string | null
    has_digital_access: boolean | null
    publisher: string | null
    grade_year: string | null
    category_id: number | null
    author: string | null
    _count: BooksCountAggregateOutputType | null
    _avg: BooksAvgAggregateOutputType | null
    _sum: BooksSumAggregateOutputType | null
    _min: BooksMinAggregateOutputType | null
    _max: BooksMaxAggregateOutputType | null
  }

  type GetBooksGroupByPayload<T extends booksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BooksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BooksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BooksGroupByOutputType[P]>
            : GetScalarType<T[P], BooksGroupByOutputType[P]>
        }
      >
    >


  export type booksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    authors?: boolean
    subject?: boolean
    code?: boolean
    edition?: boolean
    isbn?: boolean
    markup?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cover_url?: boolean
    category?: boolean
    year?: boolean
    type?: boolean
    price_gbp?: boolean
    price_ugx?: boolean
    level?: boolean
    published_date?: boolean
    format?: boolean
    has_digital_access?: boolean
    publisher?: boolean
    grade_year?: boolean
    category_id?: boolean
    author?: boolean
    book_details?: boolean | books$book_detailsArgs<ExtArgs>
    category_lookup?: boolean | books$category_lookupArgs<ExtArgs>
    cart_items?: boolean | books$cart_itemsArgs<ExtArgs>
    _count?: boolean | BooksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["books"]>

  export type booksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    authors?: boolean
    subject?: boolean
    code?: boolean
    edition?: boolean
    isbn?: boolean
    markup?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cover_url?: boolean
    category?: boolean
    year?: boolean
    type?: boolean
    price_gbp?: boolean
    price_ugx?: boolean
    level?: boolean
    published_date?: boolean
    format?: boolean
    has_digital_access?: boolean
    publisher?: boolean
    grade_year?: boolean
    category_id?: boolean
    author?: boolean
    category_lookup?: boolean | books$category_lookupArgs<ExtArgs>
  }, ExtArgs["result"]["books"]>

  export type booksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    authors?: boolean
    subject?: boolean
    code?: boolean
    edition?: boolean
    isbn?: boolean
    markup?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cover_url?: boolean
    category?: boolean
    year?: boolean
    type?: boolean
    price_gbp?: boolean
    price_ugx?: boolean
    level?: boolean
    published_date?: boolean
    format?: boolean
    has_digital_access?: boolean
    publisher?: boolean
    grade_year?: boolean
    category_id?: boolean
    author?: boolean
    category_lookup?: boolean | books$category_lookupArgs<ExtArgs>
  }, ExtArgs["result"]["books"]>

  export type booksSelectScalar = {
    id?: boolean
    title?: boolean
    authors?: boolean
    subject?: boolean
    code?: boolean
    edition?: boolean
    isbn?: boolean
    markup?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cover_url?: boolean
    category?: boolean
    year?: boolean
    type?: boolean
    price_gbp?: boolean
    price_ugx?: boolean
    level?: boolean
    published_date?: boolean
    format?: boolean
    has_digital_access?: boolean
    publisher?: boolean
    grade_year?: boolean
    category_id?: boolean
    author?: boolean
  }

  export type booksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "authors" | "subject" | "code" | "edition" | "isbn" | "markup" | "price" | "createdAt" | "updatedAt" | "cover_url" | "category" | "year" | "type" | "price_gbp" | "price_ugx" | "level" | "published_date" | "format" | "has_digital_access" | "publisher" | "grade_year" | "category_id" | "author", ExtArgs["result"]["books"]>
  export type booksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book_details?: boolean | books$book_detailsArgs<ExtArgs>
    category_lookup?: boolean | books$category_lookupArgs<ExtArgs>
    cart_items?: boolean | books$cart_itemsArgs<ExtArgs>
    _count?: boolean | BooksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type booksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category_lookup?: boolean | books$category_lookupArgs<ExtArgs>
  }
  export type booksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category_lookup?: boolean | books$category_lookupArgs<ExtArgs>
  }

  export type $booksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "books"
    objects: {
      book_details: Prisma.$book_detailsPayload<ExtArgs> | null
      category_lookup: Prisma.$category_lookupPayload<ExtArgs> | null
      cart_items: Prisma.$cart_itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      authors: string | null
      subject: string | null
      code: string | null
      edition: string | null
      isbn: string | null
      markup: number | null
      price: number | null
      createdAt: Date
      updatedAt: Date | null
      cover_url: string | null
      category: string | null
      year: string | null
      type: string | null
      price_gbp: Prisma.Decimal | null
      price_ugx: Prisma.Decimal | null
      level: string | null
      published_date: Date | null
      format: string | null
      has_digital_access: boolean | null
      publisher: string | null
      grade_year: string | null
      category_id: number | null
      author: string | null
    }, ExtArgs["result"]["books"]>
    composites: {}
  }

  type booksGetPayload<S extends boolean | null | undefined | booksDefaultArgs> = $Result.GetResult<Prisma.$booksPayload, S>

  type booksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<booksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BooksCountAggregateInputType | true
    }

  export interface booksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['books'], meta: { name: 'books' } }
    /**
     * Find zero or one Books that matches the filter.
     * @param {booksFindUniqueArgs} args - Arguments to find a Books
     * @example
     * // Get one Books
     * const books = await prisma.books.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends booksFindUniqueArgs>(args: SelectSubset<T, booksFindUniqueArgs<ExtArgs>>): Prisma__booksClient<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Books that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {booksFindUniqueOrThrowArgs} args - Arguments to find a Books
     * @example
     * // Get one Books
     * const books = await prisma.books.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends booksFindUniqueOrThrowArgs>(args: SelectSubset<T, booksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__booksClient<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booksFindFirstArgs} args - Arguments to find a Books
     * @example
     * // Get one Books
     * const books = await prisma.books.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends booksFindFirstArgs>(args?: SelectSubset<T, booksFindFirstArgs<ExtArgs>>): Prisma__booksClient<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Books that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booksFindFirstOrThrowArgs} args - Arguments to find a Books
     * @example
     * // Get one Books
     * const books = await prisma.books.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends booksFindFirstOrThrowArgs>(args?: SelectSubset<T, booksFindFirstOrThrowArgs<ExtArgs>>): Prisma__booksClient<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books
     * const books = await prisma.books.findMany()
     * 
     * // Get first 10 Books
     * const books = await prisma.books.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const booksWithIdOnly = await prisma.books.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends booksFindManyArgs>(args?: SelectSubset<T, booksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Books.
     * @param {booksCreateArgs} args - Arguments to create a Books.
     * @example
     * // Create one Books
     * const Books = await prisma.books.create({
     *   data: {
     *     // ... data to create a Books
     *   }
     * })
     * 
     */
    create<T extends booksCreateArgs>(args: SelectSubset<T, booksCreateArgs<ExtArgs>>): Prisma__booksClient<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Books.
     * @param {booksCreateManyArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const books = await prisma.books.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends booksCreateManyArgs>(args?: SelectSubset<T, booksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Books and returns the data saved in the database.
     * @param {booksCreateManyAndReturnArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const books = await prisma.books.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Books and only return the `id`
     * const booksWithIdOnly = await prisma.books.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends booksCreateManyAndReturnArgs>(args?: SelectSubset<T, booksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Books.
     * @param {booksDeleteArgs} args - Arguments to delete one Books.
     * @example
     * // Delete one Books
     * const Books = await prisma.books.delete({
     *   where: {
     *     // ... filter to delete one Books
     *   }
     * })
     * 
     */
    delete<T extends booksDeleteArgs>(args: SelectSubset<T, booksDeleteArgs<ExtArgs>>): Prisma__booksClient<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Books.
     * @param {booksUpdateArgs} args - Arguments to update one Books.
     * @example
     * // Update one Books
     * const books = await prisma.books.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends booksUpdateArgs>(args: SelectSubset<T, booksUpdateArgs<ExtArgs>>): Prisma__booksClient<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Books.
     * @param {booksDeleteManyArgs} args - Arguments to filter Books to delete.
     * @example
     * // Delete a few Books
     * const { count } = await prisma.books.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends booksDeleteManyArgs>(args?: SelectSubset<T, booksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books
     * const books = await prisma.books.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends booksUpdateManyArgs>(args: SelectSubset<T, booksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books and returns the data updated in the database.
     * @param {booksUpdateManyAndReturnArgs} args - Arguments to update many Books.
     * @example
     * // Update many Books
     * const books = await prisma.books.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Books and only return the `id`
     * const booksWithIdOnly = await prisma.books.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends booksUpdateManyAndReturnArgs>(args: SelectSubset<T, booksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Books.
     * @param {booksUpsertArgs} args - Arguments to update or create a Books.
     * @example
     * // Update or create a Books
     * const books = await prisma.books.upsert({
     *   create: {
     *     // ... data to create a Books
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Books we want to update
     *   }
     * })
     */
    upsert<T extends booksUpsertArgs>(args: SelectSubset<T, booksUpsertArgs<ExtArgs>>): Prisma__booksClient<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booksCountArgs} args - Arguments to filter Books to count.
     * @example
     * // Count the number of Books
     * const count = await prisma.books.count({
     *   where: {
     *     // ... the filter for the Books we want to count
     *   }
     * })
    **/
    count<T extends booksCountArgs>(
      args?: Subset<T, booksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BooksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BooksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BooksAggregateArgs>(args: Subset<T, BooksAggregateArgs>): Prisma.PrismaPromise<GetBooksAggregateType<T>>

    /**
     * Group by Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends booksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: booksGroupByArgs['orderBy'] }
        : { orderBy?: booksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, booksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBooksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the books model
   */
  readonly fields: booksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for books.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__booksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book_details<T extends books$book_detailsArgs<ExtArgs> = {}>(args?: Subset<T, books$book_detailsArgs<ExtArgs>>): Prisma__book_detailsClient<$Result.GetResult<Prisma.$book_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category_lookup<T extends books$category_lookupArgs<ExtArgs> = {}>(args?: Subset<T, books$category_lookupArgs<ExtArgs>>): Prisma__category_lookupClient<$Result.GetResult<Prisma.$category_lookupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cart_items<T extends books$cart_itemsArgs<ExtArgs> = {}>(args?: Subset<T, books$cart_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cart_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the books model
   */
  interface booksFieldRefs {
    readonly id: FieldRef<"books", 'Int'>
    readonly title: FieldRef<"books", 'String'>
    readonly authors: FieldRef<"books", 'String'>
    readonly subject: FieldRef<"books", 'String'>
    readonly code: FieldRef<"books", 'String'>
    readonly edition: FieldRef<"books", 'String'>
    readonly isbn: FieldRef<"books", 'String'>
    readonly markup: FieldRef<"books", 'Float'>
    readonly price: FieldRef<"books", 'Float'>
    readonly createdAt: FieldRef<"books", 'DateTime'>
    readonly updatedAt: FieldRef<"books", 'DateTime'>
    readonly cover_url: FieldRef<"books", 'String'>
    readonly category: FieldRef<"books", 'String'>
    readonly year: FieldRef<"books", 'String'>
    readonly type: FieldRef<"books", 'String'>
    readonly price_gbp: FieldRef<"books", 'Decimal'>
    readonly price_ugx: FieldRef<"books", 'Decimal'>
    readonly level: FieldRef<"books", 'String'>
    readonly published_date: FieldRef<"books", 'DateTime'>
    readonly format: FieldRef<"books", 'String'>
    readonly has_digital_access: FieldRef<"books", 'Boolean'>
    readonly publisher: FieldRef<"books", 'String'>
    readonly grade_year: FieldRef<"books", 'String'>
    readonly category_id: FieldRef<"books", 'Int'>
    readonly author: FieldRef<"books", 'String'>
  }
    

  // Custom InputTypes
  /**
   * books findUnique
   */
  export type booksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksInclude<ExtArgs> | null
    /**
     * Filter, which books to fetch.
     */
    where: booksWhereUniqueInput
  }

  /**
   * books findUniqueOrThrow
   */
  export type booksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksInclude<ExtArgs> | null
    /**
     * Filter, which books to fetch.
     */
    where: booksWhereUniqueInput
  }

  /**
   * books findFirst
   */
  export type booksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksInclude<ExtArgs> | null
    /**
     * Filter, which books to fetch.
     */
    where?: booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books to fetch.
     */
    orderBy?: booksOrderByWithRelationInput | booksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for books.
     */
    cursor?: booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of books.
     */
    distinct?: BooksScalarFieldEnum | BooksScalarFieldEnum[]
  }

  /**
   * books findFirstOrThrow
   */
  export type booksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksInclude<ExtArgs> | null
    /**
     * Filter, which books to fetch.
     */
    where?: booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books to fetch.
     */
    orderBy?: booksOrderByWithRelationInput | booksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for books.
     */
    cursor?: booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of books.
     */
    distinct?: BooksScalarFieldEnum | BooksScalarFieldEnum[]
  }

  /**
   * books findMany
   */
  export type booksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksInclude<ExtArgs> | null
    /**
     * Filter, which books to fetch.
     */
    where?: booksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books to fetch.
     */
    orderBy?: booksOrderByWithRelationInput | booksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing books.
     */
    cursor?: booksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books.
     */
    skip?: number
    distinct?: BooksScalarFieldEnum | BooksScalarFieldEnum[]
  }

  /**
   * books create
   */
  export type booksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksInclude<ExtArgs> | null
    /**
     * The data needed to create a books.
     */
    data: XOR<booksCreateInput, booksUncheckedCreateInput>
  }

  /**
   * books createMany
   */
  export type booksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many books.
     */
    data: booksCreateManyInput | booksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * books createManyAndReturn
   */
  export type booksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * The data used to create many books.
     */
    data: booksCreateManyInput | booksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * books update
   */
  export type booksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksInclude<ExtArgs> | null
    /**
     * The data needed to update a books.
     */
    data: XOR<booksUpdateInput, booksUncheckedUpdateInput>
    /**
     * Choose, which books to update.
     */
    where: booksWhereUniqueInput
  }

  /**
   * books updateMany
   */
  export type booksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update books.
     */
    data: XOR<booksUpdateManyMutationInput, booksUncheckedUpdateManyInput>
    /**
     * Filter which books to update
     */
    where?: booksWhereInput
    /**
     * Limit how many books to update.
     */
    limit?: number
  }

  /**
   * books updateManyAndReturn
   */
  export type booksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * The data used to update books.
     */
    data: XOR<booksUpdateManyMutationInput, booksUncheckedUpdateManyInput>
    /**
     * Filter which books to update
     */
    where?: booksWhereInput
    /**
     * Limit how many books to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * books upsert
   */
  export type booksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksInclude<ExtArgs> | null
    /**
     * The filter to search for the books to update in case it exists.
     */
    where: booksWhereUniqueInput
    /**
     * In case the books found by the `where` argument doesn't exist, create a new books with this data.
     */
    create: XOR<booksCreateInput, booksUncheckedCreateInput>
    /**
     * In case the books was found with the provided `where` argument, update it with this data.
     */
    update: XOR<booksUpdateInput, booksUncheckedUpdateInput>
  }

  /**
   * books delete
   */
  export type booksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksInclude<ExtArgs> | null
    /**
     * Filter which books to delete.
     */
    where: booksWhereUniqueInput
  }

  /**
   * books deleteMany
   */
  export type booksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which books to delete
     */
    where?: booksWhereInput
    /**
     * Limit how many books to delete.
     */
    limit?: number
  }

  /**
   * books.book_details
   */
  export type books$book_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_details
     */
    select?: book_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_details
     */
    omit?: book_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_detailsInclude<ExtArgs> | null
    where?: book_detailsWhereInput
  }

  /**
   * books.category_lookup
   */
  export type books$category_lookupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_lookupInclude<ExtArgs> | null
    where?: category_lookupWhereInput
  }

  /**
   * books.cart_items
   */
  export type books$cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsInclude<ExtArgs> | null
    where?: cart_itemsWhereInput
    orderBy?: cart_itemsOrderByWithRelationInput | cart_itemsOrderByWithRelationInput[]
    cursor?: cart_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Cart_itemsScalarFieldEnum | Cart_itemsScalarFieldEnum[]
  }

  /**
   * books without action
   */
  export type booksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksInclude<ExtArgs> | null
  }


  /**
   * Model cart_items
   */

  export type AggregateCart_items = {
    _count: Cart_itemsCountAggregateOutputType | null
    _avg: Cart_itemsAvgAggregateOutputType | null
    _sum: Cart_itemsSumAggregateOutputType | null
    _min: Cart_itemsMinAggregateOutputType | null
    _max: Cart_itemsMaxAggregateOutputType | null
  }

  export type Cart_itemsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    quantity: number | null
  }

  export type Cart_itemsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    quantity: number | null
  }

  export type Cart_itemsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    book_isbn: string | null
    quantity: number | null
    added_at: Date | null
  }

  export type Cart_itemsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    book_isbn: string | null
    quantity: number | null
    added_at: Date | null
  }

  export type Cart_itemsCountAggregateOutputType = {
    id: number
    user_id: number
    book_isbn: number
    quantity: number
    added_at: number
    _all: number
  }


  export type Cart_itemsAvgAggregateInputType = {
    id?: true
    user_id?: true
    quantity?: true
  }

  export type Cart_itemsSumAggregateInputType = {
    id?: true
    user_id?: true
    quantity?: true
  }

  export type Cart_itemsMinAggregateInputType = {
    id?: true
    user_id?: true
    book_isbn?: true
    quantity?: true
    added_at?: true
  }

  export type Cart_itemsMaxAggregateInputType = {
    id?: true
    user_id?: true
    book_isbn?: true
    quantity?: true
    added_at?: true
  }

  export type Cart_itemsCountAggregateInputType = {
    id?: true
    user_id?: true
    book_isbn?: true
    quantity?: true
    added_at?: true
    _all?: true
  }

  export type Cart_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cart_items to aggregate.
     */
    where?: cart_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cart_items to fetch.
     */
    orderBy?: cart_itemsOrderByWithRelationInput | cart_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cart_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` cart_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cart_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cart_items
    **/
    _count?: true | Cart_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cart_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cart_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cart_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cart_itemsMaxAggregateInputType
  }

  export type GetCart_itemsAggregateType<T extends Cart_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateCart_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart_items[P]>
      : GetScalarType<T[P], AggregateCart_items[P]>
  }




  export type cart_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cart_itemsWhereInput
    orderBy?: cart_itemsOrderByWithAggregationInput | cart_itemsOrderByWithAggregationInput[]
    by: Cart_itemsScalarFieldEnum[] | Cart_itemsScalarFieldEnum
    having?: cart_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cart_itemsCountAggregateInputType | true
    _avg?: Cart_itemsAvgAggregateInputType
    _sum?: Cart_itemsSumAggregateInputType
    _min?: Cart_itemsMinAggregateInputType
    _max?: Cart_itemsMaxAggregateInputType
  }

  export type Cart_itemsGroupByOutputType = {
    id: number
    user_id: number
    book_isbn: string
    quantity: number | null
    added_at: Date | null
    _count: Cart_itemsCountAggregateOutputType | null
    _avg: Cart_itemsAvgAggregateOutputType | null
    _sum: Cart_itemsSumAggregateOutputType | null
    _min: Cart_itemsMinAggregateOutputType | null
    _max: Cart_itemsMaxAggregateOutputType | null
  }

  type GetCart_itemsGroupByPayload<T extends cart_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cart_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cart_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cart_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Cart_itemsGroupByOutputType[P]>
        }
      >
    >


  export type cart_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_isbn?: boolean
    quantity?: boolean
    added_at?: boolean
    books?: boolean | booksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart_items"]>

  export type cart_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_isbn?: boolean
    quantity?: boolean
    added_at?: boolean
    books?: boolean | booksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart_items"]>

  export type cart_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    book_isbn?: boolean
    quantity?: boolean
    added_at?: boolean
    books?: boolean | booksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart_items"]>

  export type cart_itemsSelectScalar = {
    id?: boolean
    user_id?: boolean
    book_isbn?: boolean
    quantity?: boolean
    added_at?: boolean
  }

  export type cart_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "book_isbn" | "quantity" | "added_at", ExtArgs["result"]["cart_items"]>
  export type cart_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | booksDefaultArgs<ExtArgs>
  }
  export type cart_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | booksDefaultArgs<ExtArgs>
  }
  export type cart_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | booksDefaultArgs<ExtArgs>
  }

  export type $cart_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cart_items"
    objects: {
      books: Prisma.$booksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      book_isbn: string
      quantity: number | null
      added_at: Date | null
    }, ExtArgs["result"]["cart_items"]>
    composites: {}
  }

  type cart_itemsGetPayload<S extends boolean | null | undefined | cart_itemsDefaultArgs> = $Result.GetResult<Prisma.$cart_itemsPayload, S>

  type cart_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cart_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cart_itemsCountAggregateInputType | true
    }

  export interface cart_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cart_items'], meta: { name: 'cart_items' } }
    /**
     * Find zero or one Cart_items that matches the filter.
     * @param {cart_itemsFindUniqueArgs} args - Arguments to find a Cart_items
     * @example
     * // Get one Cart_items
     * const cart_items = await prisma.cart_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cart_itemsFindUniqueArgs>(args: SelectSubset<T, cart_itemsFindUniqueArgs<ExtArgs>>): Prisma__cart_itemsClient<$Result.GetResult<Prisma.$cart_itemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart_items that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cart_itemsFindUniqueOrThrowArgs} args - Arguments to find a Cart_items
     * @example
     * // Get one Cart_items
     * const cart_items = await prisma.cart_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cart_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, cart_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cart_itemsClient<$Result.GetResult<Prisma.$cart_itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cart_itemsFindFirstArgs} args - Arguments to find a Cart_items
     * @example
     * // Get one Cart_items
     * const cart_items = await prisma.cart_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cart_itemsFindFirstArgs>(args?: SelectSubset<T, cart_itemsFindFirstArgs<ExtArgs>>): Prisma__cart_itemsClient<$Result.GetResult<Prisma.$cart_itemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cart_itemsFindFirstOrThrowArgs} args - Arguments to find a Cart_items
     * @example
     * // Get one Cart_items
     * const cart_items = await prisma.cart_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cart_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, cart_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__cart_itemsClient<$Result.GetResult<Prisma.$cart_itemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cart_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cart_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cart_items
     * const cart_items = await prisma.cart_items.findMany()
     * 
     * // Get first 10 Cart_items
     * const cart_items = await prisma.cart_items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cart_itemsWithIdOnly = await prisma.cart_items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cart_itemsFindManyArgs>(args?: SelectSubset<T, cart_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cart_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart_items.
     * @param {cart_itemsCreateArgs} args - Arguments to create a Cart_items.
     * @example
     * // Create one Cart_items
     * const Cart_items = await prisma.cart_items.create({
     *   data: {
     *     // ... data to create a Cart_items
     *   }
     * })
     * 
     */
    create<T extends cart_itemsCreateArgs>(args: SelectSubset<T, cart_itemsCreateArgs<ExtArgs>>): Prisma__cart_itemsClient<$Result.GetResult<Prisma.$cart_itemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cart_items.
     * @param {cart_itemsCreateManyArgs} args - Arguments to create many Cart_items.
     * @example
     * // Create many Cart_items
     * const cart_items = await prisma.cart_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cart_itemsCreateManyArgs>(args?: SelectSubset<T, cart_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cart_items and returns the data saved in the database.
     * @param {cart_itemsCreateManyAndReturnArgs} args - Arguments to create many Cart_items.
     * @example
     * // Create many Cart_items
     * const cart_items = await prisma.cart_items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cart_items and only return the `id`
     * const cart_itemsWithIdOnly = await prisma.cart_items.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cart_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, cart_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cart_itemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cart_items.
     * @param {cart_itemsDeleteArgs} args - Arguments to delete one Cart_items.
     * @example
     * // Delete one Cart_items
     * const Cart_items = await prisma.cart_items.delete({
     *   where: {
     *     // ... filter to delete one Cart_items
     *   }
     * })
     * 
     */
    delete<T extends cart_itemsDeleteArgs>(args: SelectSubset<T, cart_itemsDeleteArgs<ExtArgs>>): Prisma__cart_itemsClient<$Result.GetResult<Prisma.$cart_itemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart_items.
     * @param {cart_itemsUpdateArgs} args - Arguments to update one Cart_items.
     * @example
     * // Update one Cart_items
     * const cart_items = await prisma.cart_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cart_itemsUpdateArgs>(args: SelectSubset<T, cart_itemsUpdateArgs<ExtArgs>>): Prisma__cart_itemsClient<$Result.GetResult<Prisma.$cart_itemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cart_items.
     * @param {cart_itemsDeleteManyArgs} args - Arguments to filter Cart_items to delete.
     * @example
     * // Delete a few Cart_items
     * const { count } = await prisma.cart_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cart_itemsDeleteManyArgs>(args?: SelectSubset<T, cart_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cart_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cart_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cart_items
     * const cart_items = await prisma.cart_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cart_itemsUpdateManyArgs>(args: SelectSubset<T, cart_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cart_items and returns the data updated in the database.
     * @param {cart_itemsUpdateManyAndReturnArgs} args - Arguments to update many Cart_items.
     * @example
     * // Update many Cart_items
     * const cart_items = await prisma.cart_items.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cart_items and only return the `id`
     * const cart_itemsWithIdOnly = await prisma.cart_items.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cart_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, cart_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cart_itemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cart_items.
     * @param {cart_itemsUpsertArgs} args - Arguments to update or create a Cart_items.
     * @example
     * // Update or create a Cart_items
     * const cart_items = await prisma.cart_items.upsert({
     *   create: {
     *     // ... data to create a Cart_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart_items we want to update
     *   }
     * })
     */
    upsert<T extends cart_itemsUpsertArgs>(args: SelectSubset<T, cart_itemsUpsertArgs<ExtArgs>>): Prisma__cart_itemsClient<$Result.GetResult<Prisma.$cart_itemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cart_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cart_itemsCountArgs} args - Arguments to filter Cart_items to count.
     * @example
     * // Count the number of Cart_items
     * const count = await prisma.cart_items.count({
     *   where: {
     *     // ... the filter for the Cart_items we want to count
     *   }
     * })
    **/
    count<T extends cart_itemsCountArgs>(
      args?: Subset<T, cart_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cart_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cart_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cart_itemsAggregateArgs>(args: Subset<T, Cart_itemsAggregateArgs>): Prisma.PrismaPromise<GetCart_itemsAggregateType<T>>

    /**
     * Group by Cart_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cart_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cart_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cart_itemsGroupByArgs['orderBy'] }
        : { orderBy?: cart_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cart_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCart_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cart_items model
   */
  readonly fields: cart_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cart_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cart_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends booksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, booksDefaultArgs<ExtArgs>>): Prisma__booksClient<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cart_items model
   */
  interface cart_itemsFieldRefs {
    readonly id: FieldRef<"cart_items", 'Int'>
    readonly user_id: FieldRef<"cart_items", 'Int'>
    readonly book_isbn: FieldRef<"cart_items", 'String'>
    readonly quantity: FieldRef<"cart_items", 'Int'>
    readonly added_at: FieldRef<"cart_items", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cart_items findUnique
   */
  export type cart_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsInclude<ExtArgs> | null
    /**
     * Filter, which cart_items to fetch.
     */
    where: cart_itemsWhereUniqueInput
  }

  /**
   * cart_items findUniqueOrThrow
   */
  export type cart_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsInclude<ExtArgs> | null
    /**
     * Filter, which cart_items to fetch.
     */
    where: cart_itemsWhereUniqueInput
  }

  /**
   * cart_items findFirst
   */
  export type cart_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsInclude<ExtArgs> | null
    /**
     * Filter, which cart_items to fetch.
     */
    where?: cart_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cart_items to fetch.
     */
    orderBy?: cart_itemsOrderByWithRelationInput | cart_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cart_items.
     */
    cursor?: cart_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` cart_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cart_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cart_items.
     */
    distinct?: Cart_itemsScalarFieldEnum | Cart_itemsScalarFieldEnum[]
  }

  /**
   * cart_items findFirstOrThrow
   */
  export type cart_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsInclude<ExtArgs> | null
    /**
     * Filter, which cart_items to fetch.
     */
    where?: cart_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cart_items to fetch.
     */
    orderBy?: cart_itemsOrderByWithRelationInput | cart_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cart_items.
     */
    cursor?: cart_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` cart_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cart_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cart_items.
     */
    distinct?: Cart_itemsScalarFieldEnum | Cart_itemsScalarFieldEnum[]
  }

  /**
   * cart_items findMany
   */
  export type cart_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsInclude<ExtArgs> | null
    /**
     * Filter, which cart_items to fetch.
     */
    where?: cart_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cart_items to fetch.
     */
    orderBy?: cart_itemsOrderByWithRelationInput | cart_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cart_items.
     */
    cursor?: cart_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` cart_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cart_items.
     */
    skip?: number
    distinct?: Cart_itemsScalarFieldEnum | Cart_itemsScalarFieldEnum[]
  }

  /**
   * cart_items create
   */
  export type cart_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a cart_items.
     */
    data: XOR<cart_itemsCreateInput, cart_itemsUncheckedCreateInput>
  }

  /**
   * cart_items createMany
   */
  export type cart_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cart_items.
     */
    data: cart_itemsCreateManyInput | cart_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cart_items createManyAndReturn
   */
  export type cart_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * The data used to create many cart_items.
     */
    data: cart_itemsCreateManyInput | cart_itemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * cart_items update
   */
  export type cart_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a cart_items.
     */
    data: XOR<cart_itemsUpdateInput, cart_itemsUncheckedUpdateInput>
    /**
     * Choose, which cart_items to update.
     */
    where: cart_itemsWhereUniqueInput
  }

  /**
   * cart_items updateMany
   */
  export type cart_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cart_items.
     */
    data: XOR<cart_itemsUpdateManyMutationInput, cart_itemsUncheckedUpdateManyInput>
    /**
     * Filter which cart_items to update
     */
    where?: cart_itemsWhereInput
    /**
     * Limit how many cart_items to update.
     */
    limit?: number
  }

  /**
   * cart_items updateManyAndReturn
   */
  export type cart_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * The data used to update cart_items.
     */
    data: XOR<cart_itemsUpdateManyMutationInput, cart_itemsUncheckedUpdateManyInput>
    /**
     * Filter which cart_items to update
     */
    where?: cart_itemsWhereInput
    /**
     * Limit how many cart_items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * cart_items upsert
   */
  export type cart_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the cart_items to update in case it exists.
     */
    where: cart_itemsWhereUniqueInput
    /**
     * In case the cart_items found by the `where` argument doesn't exist, create a new cart_items with this data.
     */
    create: XOR<cart_itemsCreateInput, cart_itemsUncheckedCreateInput>
    /**
     * In case the cart_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cart_itemsUpdateInput, cart_itemsUncheckedUpdateInput>
  }

  /**
   * cart_items delete
   */
  export type cart_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsInclude<ExtArgs> | null
    /**
     * Filter which cart_items to delete.
     */
    where: cart_itemsWhereUniqueInput
  }

  /**
   * cart_items deleteMany
   */
  export type cart_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cart_items to delete
     */
    where?: cart_itemsWhereInput
    /**
     * Limit how many cart_items to delete.
     */
    limit?: number
  }

  /**
   * cart_items without action
   */
  export type cart_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_items
     */
    select?: cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cart_items
     */
    omit?: cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cart_itemsInclude<ExtArgs> | null
  }


  /**
   * Model category_lookup
   */

  export type AggregateCategory_lookup = {
    _count: Category_lookupCountAggregateOutputType | null
    _avg: Category_lookupAvgAggregateOutputType | null
    _sum: Category_lookupSumAggregateOutputType | null
    _min: Category_lookupMinAggregateOutputType | null
    _max: Category_lookupMaxAggregateOutputType | null
  }

  export type Category_lookupAvgAggregateOutputType = {
    id: number | null
  }

  export type Category_lookupSumAggregateOutputType = {
    id: number | null
  }

  export type Category_lookupMinAggregateOutputType = {
    id: number | null
    category_name: string | null
  }

  export type Category_lookupMaxAggregateOutputType = {
    id: number | null
    category_name: string | null
  }

  export type Category_lookupCountAggregateOutputType = {
    id: number
    category_name: number
    _all: number
  }


  export type Category_lookupAvgAggregateInputType = {
    id?: true
  }

  export type Category_lookupSumAggregateInputType = {
    id?: true
  }

  export type Category_lookupMinAggregateInputType = {
    id?: true
    category_name?: true
  }

  export type Category_lookupMaxAggregateInputType = {
    id?: true
    category_name?: true
  }

  export type Category_lookupCountAggregateInputType = {
    id?: true
    category_name?: true
    _all?: true
  }

  export type Category_lookupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category_lookup to aggregate.
     */
    where?: category_lookupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_lookups to fetch.
     */
    orderBy?: category_lookupOrderByWithRelationInput | category_lookupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: category_lookupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` category_lookups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_lookups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned category_lookups
    **/
    _count?: true | Category_lookupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Category_lookupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Category_lookupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Category_lookupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Category_lookupMaxAggregateInputType
  }

  export type GetCategory_lookupAggregateType<T extends Category_lookupAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory_lookup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory_lookup[P]>
      : GetScalarType<T[P], AggregateCategory_lookup[P]>
  }




  export type category_lookupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: category_lookupWhereInput
    orderBy?: category_lookupOrderByWithAggregationInput | category_lookupOrderByWithAggregationInput[]
    by: Category_lookupScalarFieldEnum[] | Category_lookupScalarFieldEnum
    having?: category_lookupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Category_lookupCountAggregateInputType | true
    _avg?: Category_lookupAvgAggregateInputType
    _sum?: Category_lookupSumAggregateInputType
    _min?: Category_lookupMinAggregateInputType
    _max?: Category_lookupMaxAggregateInputType
  }

  export type Category_lookupGroupByOutputType = {
    id: number
    category_name: string
    _count: Category_lookupCountAggregateOutputType | null
    _avg: Category_lookupAvgAggregateOutputType | null
    _sum: Category_lookupSumAggregateOutputType | null
    _min: Category_lookupMinAggregateOutputType | null
    _max: Category_lookupMaxAggregateOutputType | null
  }

  type GetCategory_lookupGroupByPayload<T extends category_lookupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Category_lookupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Category_lookupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Category_lookupGroupByOutputType[P]>
            : GetScalarType<T[P], Category_lookupGroupByOutputType[P]>
        }
      >
    >


  export type category_lookupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_name?: boolean
    books?: boolean | category_lookup$booksArgs<ExtArgs>
    _count?: boolean | Category_lookupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category_lookup"]>

  export type category_lookupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_name?: boolean
  }, ExtArgs["result"]["category_lookup"]>

  export type category_lookupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_name?: boolean
  }, ExtArgs["result"]["category_lookup"]>

  export type category_lookupSelectScalar = {
    id?: boolean
    category_name?: boolean
  }

  export type category_lookupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category_name", ExtArgs["result"]["category_lookup"]>
  export type category_lookupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | category_lookup$booksArgs<ExtArgs>
    _count?: boolean | Category_lookupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type category_lookupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type category_lookupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $category_lookupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category_lookup"
    objects: {
      books: Prisma.$booksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category_name: string
    }, ExtArgs["result"]["category_lookup"]>
    composites: {}
  }

  type category_lookupGetPayload<S extends boolean | null | undefined | category_lookupDefaultArgs> = $Result.GetResult<Prisma.$category_lookupPayload, S>

  type category_lookupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<category_lookupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Category_lookupCountAggregateInputType | true
    }

  export interface category_lookupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category_lookup'], meta: { name: 'category_lookup' } }
    /**
     * Find zero or one Category_lookup that matches the filter.
     * @param {category_lookupFindUniqueArgs} args - Arguments to find a Category_lookup
     * @example
     * // Get one Category_lookup
     * const category_lookup = await prisma.category_lookup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends category_lookupFindUniqueArgs>(args: SelectSubset<T, category_lookupFindUniqueArgs<ExtArgs>>): Prisma__category_lookupClient<$Result.GetResult<Prisma.$category_lookupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category_lookup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {category_lookupFindUniqueOrThrowArgs} args - Arguments to find a Category_lookup
     * @example
     * // Get one Category_lookup
     * const category_lookup = await prisma.category_lookup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends category_lookupFindUniqueOrThrowArgs>(args: SelectSubset<T, category_lookupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__category_lookupClient<$Result.GetResult<Prisma.$category_lookupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category_lookup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_lookupFindFirstArgs} args - Arguments to find a Category_lookup
     * @example
     * // Get one Category_lookup
     * const category_lookup = await prisma.category_lookup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends category_lookupFindFirstArgs>(args?: SelectSubset<T, category_lookupFindFirstArgs<ExtArgs>>): Prisma__category_lookupClient<$Result.GetResult<Prisma.$category_lookupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category_lookup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_lookupFindFirstOrThrowArgs} args - Arguments to find a Category_lookup
     * @example
     * // Get one Category_lookup
     * const category_lookup = await prisma.category_lookup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends category_lookupFindFirstOrThrowArgs>(args?: SelectSubset<T, category_lookupFindFirstOrThrowArgs<ExtArgs>>): Prisma__category_lookupClient<$Result.GetResult<Prisma.$category_lookupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Category_lookups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_lookupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Category_lookups
     * const category_lookups = await prisma.category_lookup.findMany()
     * 
     * // Get first 10 Category_lookups
     * const category_lookups = await prisma.category_lookup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const category_lookupWithIdOnly = await prisma.category_lookup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends category_lookupFindManyArgs>(args?: SelectSubset<T, category_lookupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_lookupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category_lookup.
     * @param {category_lookupCreateArgs} args - Arguments to create a Category_lookup.
     * @example
     * // Create one Category_lookup
     * const Category_lookup = await prisma.category_lookup.create({
     *   data: {
     *     // ... data to create a Category_lookup
     *   }
     * })
     * 
     */
    create<T extends category_lookupCreateArgs>(args: SelectSubset<T, category_lookupCreateArgs<ExtArgs>>): Prisma__category_lookupClient<$Result.GetResult<Prisma.$category_lookupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Category_lookups.
     * @param {category_lookupCreateManyArgs} args - Arguments to create many Category_lookups.
     * @example
     * // Create many Category_lookups
     * const category_lookup = await prisma.category_lookup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends category_lookupCreateManyArgs>(args?: SelectSubset<T, category_lookupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Category_lookups and returns the data saved in the database.
     * @param {category_lookupCreateManyAndReturnArgs} args - Arguments to create many Category_lookups.
     * @example
     * // Create many Category_lookups
     * const category_lookup = await prisma.category_lookup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Category_lookups and only return the `id`
     * const category_lookupWithIdOnly = await prisma.category_lookup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends category_lookupCreateManyAndReturnArgs>(args?: SelectSubset<T, category_lookupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_lookupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category_lookup.
     * @param {category_lookupDeleteArgs} args - Arguments to delete one Category_lookup.
     * @example
     * // Delete one Category_lookup
     * const Category_lookup = await prisma.category_lookup.delete({
     *   where: {
     *     // ... filter to delete one Category_lookup
     *   }
     * })
     * 
     */
    delete<T extends category_lookupDeleteArgs>(args: SelectSubset<T, category_lookupDeleteArgs<ExtArgs>>): Prisma__category_lookupClient<$Result.GetResult<Prisma.$category_lookupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category_lookup.
     * @param {category_lookupUpdateArgs} args - Arguments to update one Category_lookup.
     * @example
     * // Update one Category_lookup
     * const category_lookup = await prisma.category_lookup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends category_lookupUpdateArgs>(args: SelectSubset<T, category_lookupUpdateArgs<ExtArgs>>): Prisma__category_lookupClient<$Result.GetResult<Prisma.$category_lookupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Category_lookups.
     * @param {category_lookupDeleteManyArgs} args - Arguments to filter Category_lookups to delete.
     * @example
     * // Delete a few Category_lookups
     * const { count } = await prisma.category_lookup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends category_lookupDeleteManyArgs>(args?: SelectSubset<T, category_lookupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Category_lookups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_lookupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Category_lookups
     * const category_lookup = await prisma.category_lookup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends category_lookupUpdateManyArgs>(args: SelectSubset<T, category_lookupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Category_lookups and returns the data updated in the database.
     * @param {category_lookupUpdateManyAndReturnArgs} args - Arguments to update many Category_lookups.
     * @example
     * // Update many Category_lookups
     * const category_lookup = await prisma.category_lookup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Category_lookups and only return the `id`
     * const category_lookupWithIdOnly = await prisma.category_lookup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends category_lookupUpdateManyAndReturnArgs>(args: SelectSubset<T, category_lookupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_lookupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category_lookup.
     * @param {category_lookupUpsertArgs} args - Arguments to update or create a Category_lookup.
     * @example
     * // Update or create a Category_lookup
     * const category_lookup = await prisma.category_lookup.upsert({
     *   create: {
     *     // ... data to create a Category_lookup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category_lookup we want to update
     *   }
     * })
     */
    upsert<T extends category_lookupUpsertArgs>(args: SelectSubset<T, category_lookupUpsertArgs<ExtArgs>>): Prisma__category_lookupClient<$Result.GetResult<Prisma.$category_lookupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Category_lookups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_lookupCountArgs} args - Arguments to filter Category_lookups to count.
     * @example
     * // Count the number of Category_lookups
     * const count = await prisma.category_lookup.count({
     *   where: {
     *     // ... the filter for the Category_lookups we want to count
     *   }
     * })
    **/
    count<T extends category_lookupCountArgs>(
      args?: Subset<T, category_lookupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Category_lookupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category_lookup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Category_lookupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Category_lookupAggregateArgs>(args: Subset<T, Category_lookupAggregateArgs>): Prisma.PrismaPromise<GetCategory_lookupAggregateType<T>>

    /**
     * Group by Category_lookup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_lookupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends category_lookupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: category_lookupGroupByArgs['orderBy'] }
        : { orderBy?: category_lookupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, category_lookupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategory_lookupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category_lookup model
   */
  readonly fields: category_lookupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category_lookup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__category_lookupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends category_lookup$booksArgs<ExtArgs> = {}>(args?: Subset<T, category_lookup$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the category_lookup model
   */
  interface category_lookupFieldRefs {
    readonly id: FieldRef<"category_lookup", 'Int'>
    readonly category_name: FieldRef<"category_lookup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * category_lookup findUnique
   */
  export type category_lookupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_lookupInclude<ExtArgs> | null
    /**
     * Filter, which category_lookup to fetch.
     */
    where: category_lookupWhereUniqueInput
  }

  /**
   * category_lookup findUniqueOrThrow
   */
  export type category_lookupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_lookupInclude<ExtArgs> | null
    /**
     * Filter, which category_lookup to fetch.
     */
    where: category_lookupWhereUniqueInput
  }

  /**
   * category_lookup findFirst
   */
  export type category_lookupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_lookupInclude<ExtArgs> | null
    /**
     * Filter, which category_lookup to fetch.
     */
    where?: category_lookupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_lookups to fetch.
     */
    orderBy?: category_lookupOrderByWithRelationInput | category_lookupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for category_lookups.
     */
    cursor?: category_lookupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` category_lookups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_lookups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of category_lookups.
     */
    distinct?: Category_lookupScalarFieldEnum | Category_lookupScalarFieldEnum[]
  }

  /**
   * category_lookup findFirstOrThrow
   */
  export type category_lookupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_lookupInclude<ExtArgs> | null
    /**
     * Filter, which category_lookup to fetch.
     */
    where?: category_lookupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_lookups to fetch.
     */
    orderBy?: category_lookupOrderByWithRelationInput | category_lookupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for category_lookups.
     */
    cursor?: category_lookupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` category_lookups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_lookups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of category_lookups.
     */
    distinct?: Category_lookupScalarFieldEnum | Category_lookupScalarFieldEnum[]
  }

  /**
   * category_lookup findMany
   */
  export type category_lookupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_lookupInclude<ExtArgs> | null
    /**
     * Filter, which category_lookups to fetch.
     */
    where?: category_lookupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_lookups to fetch.
     */
    orderBy?: category_lookupOrderByWithRelationInput | category_lookupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing category_lookups.
     */
    cursor?: category_lookupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` category_lookups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_lookups.
     */
    skip?: number
    distinct?: Category_lookupScalarFieldEnum | Category_lookupScalarFieldEnum[]
  }

  /**
   * category_lookup create
   */
  export type category_lookupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_lookupInclude<ExtArgs> | null
    /**
     * The data needed to create a category_lookup.
     */
    data: XOR<category_lookupCreateInput, category_lookupUncheckedCreateInput>
  }

  /**
   * category_lookup createMany
   */
  export type category_lookupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many category_lookups.
     */
    data: category_lookupCreateManyInput | category_lookupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category_lookup createManyAndReturn
   */
  export type category_lookupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * The data used to create many category_lookups.
     */
    data: category_lookupCreateManyInput | category_lookupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category_lookup update
   */
  export type category_lookupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_lookupInclude<ExtArgs> | null
    /**
     * The data needed to update a category_lookup.
     */
    data: XOR<category_lookupUpdateInput, category_lookupUncheckedUpdateInput>
    /**
     * Choose, which category_lookup to update.
     */
    where: category_lookupWhereUniqueInput
  }

  /**
   * category_lookup updateMany
   */
  export type category_lookupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update category_lookups.
     */
    data: XOR<category_lookupUpdateManyMutationInput, category_lookupUncheckedUpdateManyInput>
    /**
     * Filter which category_lookups to update
     */
    where?: category_lookupWhereInput
    /**
     * Limit how many category_lookups to update.
     */
    limit?: number
  }

  /**
   * category_lookup updateManyAndReturn
   */
  export type category_lookupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * The data used to update category_lookups.
     */
    data: XOR<category_lookupUpdateManyMutationInput, category_lookupUncheckedUpdateManyInput>
    /**
     * Filter which category_lookups to update
     */
    where?: category_lookupWhereInput
    /**
     * Limit how many category_lookups to update.
     */
    limit?: number
  }

  /**
   * category_lookup upsert
   */
  export type category_lookupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_lookupInclude<ExtArgs> | null
    /**
     * The filter to search for the category_lookup to update in case it exists.
     */
    where: category_lookupWhereUniqueInput
    /**
     * In case the category_lookup found by the `where` argument doesn't exist, create a new category_lookup with this data.
     */
    create: XOR<category_lookupCreateInput, category_lookupUncheckedCreateInput>
    /**
     * In case the category_lookup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<category_lookupUpdateInput, category_lookupUncheckedUpdateInput>
  }

  /**
   * category_lookup delete
   */
  export type category_lookupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_lookupInclude<ExtArgs> | null
    /**
     * Filter which category_lookup to delete.
     */
    where: category_lookupWhereUniqueInput
  }

  /**
   * category_lookup deleteMany
   */
  export type category_lookupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category_lookups to delete
     */
    where?: category_lookupWhereInput
    /**
     * Limit how many category_lookups to delete.
     */
    limit?: number
  }

  /**
   * category_lookup.books
   */
  export type category_lookup$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the books
     */
    select?: booksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the books
     */
    omit?: booksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booksInclude<ExtArgs> | null
    where?: booksWhereInput
    orderBy?: booksOrderByWithRelationInput | booksOrderByWithRelationInput[]
    cursor?: booksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BooksScalarFieldEnum | BooksScalarFieldEnum[]
  }

  /**
   * category_lookup without action
   */
  export type category_lookupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_lookup
     */
    select?: category_lookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_lookup
     */
    omit?: category_lookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_lookupInclude<ExtArgs> | null
  }


  /**
   * Model orders
   */

  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    id: number | null
    total_ugx: number | null
    markup_ugx: number | null
    mallory_share: number | null
  }

  export type OrdersSumAggregateOutputType = {
    id: number | null
    total_ugx: number | null
    markup_ugx: number | null
    mallory_share: number | null
  }

  export type OrdersMinAggregateOutputType = {
    id: number | null
    parent_name: string | null
    parent_email: string | null
    total_ugx: number | null
    payment_method: string | null
    markup_ugx: number | null
    mallory_share: number | null
    items_json: string | null
    status: string | null
    tx_ref: string | null
    payment_link: string | null
    created_at: Date | null
  }

  export type OrdersMaxAggregateOutputType = {
    id: number | null
    parent_name: string | null
    parent_email: string | null
    total_ugx: number | null
    payment_method: string | null
    markup_ugx: number | null
    mallory_share: number | null
    items_json: string | null
    status: string | null
    tx_ref: string | null
    payment_link: string | null
    created_at: Date | null
  }

  export type OrdersCountAggregateOutputType = {
    id: number
    parent_name: number
    parent_email: number
    total_ugx: number
    payment_method: number
    markup_ugx: number
    mallory_share: number
    items_json: number
    status: number
    tx_ref: number
    payment_link: number
    created_at: number
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    id?: true
    total_ugx?: true
    markup_ugx?: true
    mallory_share?: true
  }

  export type OrdersSumAggregateInputType = {
    id?: true
    total_ugx?: true
    markup_ugx?: true
    mallory_share?: true
  }

  export type OrdersMinAggregateInputType = {
    id?: true
    parent_name?: true
    parent_email?: true
    total_ugx?: true
    payment_method?: true
    markup_ugx?: true
    mallory_share?: true
    items_json?: true
    status?: true
    tx_ref?: true
    payment_link?: true
    created_at?: true
  }

  export type OrdersMaxAggregateInputType = {
    id?: true
    parent_name?: true
    parent_email?: true
    total_ugx?: true
    payment_method?: true
    markup_ugx?: true
    mallory_share?: true
    items_json?: true
    status?: true
    tx_ref?: true
    payment_link?: true
    created_at?: true
  }

  export type OrdersCountAggregateInputType = {
    id?: true
    parent_name?: true
    parent_email?: true
    total_ugx?: true
    payment_method?: true
    markup_ugx?: true
    mallory_share?: true
    items_json?: true
    status?: true
    tx_ref?: true
    payment_link?: true
    created_at?: true
    _all?: true
  }

  export type OrdersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to aggregate.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type ordersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithAggregationInput | ordersOrderByWithAggregationInput[]
    by: OrdersScalarFieldEnum[] | OrdersScalarFieldEnum
    having?: ordersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _avg?: OrdersAvgAggregateInputType
    _sum?: OrdersSumAggregateInputType
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }

  export type OrdersGroupByOutputType = {
    id: number
    parent_name: string
    parent_email: string
    total_ugx: number
    payment_method: string
    markup_ugx: number
    mallory_share: number
    items_json: string
    status: string | null
    tx_ref: string | null
    payment_link: string | null
    created_at: Date | null
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends ordersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type ordersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parent_name?: boolean
    parent_email?: boolean
    total_ugx?: boolean
    payment_method?: boolean
    markup_ugx?: boolean
    mallory_share?: boolean
    items_json?: boolean
    status?: boolean
    tx_ref?: boolean
    payment_link?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parent_name?: boolean
    parent_email?: boolean
    total_ugx?: boolean
    payment_method?: boolean
    markup_ugx?: boolean
    mallory_share?: boolean
    items_json?: boolean
    status?: boolean
    tx_ref?: boolean
    payment_link?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parent_name?: boolean
    parent_email?: boolean
    total_ugx?: boolean
    payment_method?: boolean
    markup_ugx?: boolean
    mallory_share?: boolean
    items_json?: boolean
    status?: boolean
    tx_ref?: boolean
    payment_link?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectScalar = {
    id?: boolean
    parent_name?: boolean
    parent_email?: boolean
    total_ugx?: boolean
    payment_method?: boolean
    markup_ugx?: boolean
    mallory_share?: boolean
    items_json?: boolean
    status?: boolean
    tx_ref?: boolean
    payment_link?: boolean
    created_at?: boolean
  }

  export type ordersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "parent_name" | "parent_email" | "total_ugx" | "payment_method" | "markup_ugx" | "mallory_share" | "items_json" | "status" | "tx_ref" | "payment_link" | "created_at", ExtArgs["result"]["orders"]>

  export type $ordersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orders"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      parent_name: string
      parent_email: string
      total_ugx: number
      payment_method: string
      markup_ugx: number
      mallory_share: number
      items_json: string
      status: string | null
      tx_ref: string | null
      payment_link: string | null
      created_at: Date | null
    }, ExtArgs["result"]["orders"]>
    composites: {}
  }

  type ordersGetPayload<S extends boolean | null | undefined | ordersDefaultArgs> = $Result.GetResult<Prisma.$ordersPayload, S>

  type ordersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ordersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrdersCountAggregateInputType | true
    }

  export interface ordersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orders'], meta: { name: 'orders' } }
    /**
     * Find zero or one Orders that matches the filter.
     * @param {ordersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ordersFindUniqueArgs>(args: SelectSubset<T, ordersFindUniqueArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Orders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ordersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ordersFindUniqueOrThrowArgs>(args: SelectSubset<T, ordersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ordersFindFirstArgs>(args?: SelectSubset<T, ordersFindFirstArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ordersFindFirstOrThrowArgs>(args?: SelectSubset<T, ordersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordersWithIdOnly = await prisma.orders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ordersFindManyArgs>(args?: SelectSubset<T, ordersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Orders.
     * @param {ordersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
     */
    create<T extends ordersCreateArgs>(args: SelectSubset<T, ordersCreateArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {ordersCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ordersCreateManyArgs>(args?: SelectSubset<T, ordersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {ordersCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const ordersWithIdOnly = await prisma.orders.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ordersCreateManyAndReturnArgs>(args?: SelectSubset<T, ordersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Orders.
     * @param {ordersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
     */
    delete<T extends ordersDeleteArgs>(args: SelectSubset<T, ordersDeleteArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Orders.
     * @param {ordersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ordersUpdateArgs>(args: SelectSubset<T, ordersUpdateArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {ordersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ordersDeleteManyArgs>(args?: SelectSubset<T, ordersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ordersUpdateManyArgs>(args: SelectSubset<T, ordersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {ordersUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const ordersWithIdOnly = await prisma.orders.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ordersUpdateManyAndReturnArgs>(args: SelectSubset<T, ordersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Orders.
     * @param {ordersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
     */
    upsert<T extends ordersUpsertArgs>(args: SelectSubset<T, ordersUpsertArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends ordersCountArgs>(
      args?: Subset<T, ordersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): Prisma.PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ordersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ordersGroupByArgs['orderBy'] }
        : { orderBy?: ordersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orders model
   */
  readonly fields: ordersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ordersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the orders model
   */
  interface ordersFieldRefs {
    readonly id: FieldRef<"orders", 'Int'>
    readonly parent_name: FieldRef<"orders", 'String'>
    readonly parent_email: FieldRef<"orders", 'String'>
    readonly total_ugx: FieldRef<"orders", 'Int'>
    readonly payment_method: FieldRef<"orders", 'String'>
    readonly markup_ugx: FieldRef<"orders", 'Int'>
    readonly mallory_share: FieldRef<"orders", 'Int'>
    readonly items_json: FieldRef<"orders", 'String'>
    readonly status: FieldRef<"orders", 'String'>
    readonly tx_ref: FieldRef<"orders", 'String'>
    readonly payment_link: FieldRef<"orders", 'String'>
    readonly created_at: FieldRef<"orders", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * orders findUnique
   */
  export type ordersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders findUniqueOrThrow
   */
  export type ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders findFirst
   */
  export type ordersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders findFirstOrThrow
   */
  export type ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders findMany
   */
  export type ordersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders create
   */
  export type ordersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * The data needed to create a orders.
     */
    data: XOR<ordersCreateInput, ordersUncheckedCreateInput>
  }

  /**
   * orders createMany
   */
  export type ordersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orders.
     */
    data: ordersCreateManyInput | ordersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orders createManyAndReturn
   */
  export type ordersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * The data used to create many orders.
     */
    data: ordersCreateManyInput | ordersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orders update
   */
  export type ordersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * The data needed to update a orders.
     */
    data: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
    /**
     * Choose, which orders to update.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders updateMany
   */
  export type ordersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orders.
     */
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: ordersWhereInput
    /**
     * Limit how many orders to update.
     */
    limit?: number
  }

  /**
   * orders updateManyAndReturn
   */
  export type ordersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * The data used to update orders.
     */
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: ordersWhereInput
    /**
     * Limit how many orders to update.
     */
    limit?: number
  }

  /**
   * orders upsert
   */
  export type ordersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * The filter to search for the orders to update in case it exists.
     */
    where: ordersWhereUniqueInput
    /**
     * In case the orders found by the `where` argument doesn't exist, create a new orders with this data.
     */
    create: XOR<ordersCreateInput, ordersUncheckedCreateInput>
    /**
     * In case the orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
  }

  /**
   * orders delete
   */
  export type ordersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Filter which orders to delete.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders deleteMany
   */
  export type ordersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to delete
     */
    where?: ordersWhereInput
    /**
     * Limit how many orders to delete.
     */
    limit?: number
  }

  /**
   * orders without action
   */
  export type ordersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
  }


  /**
   * Model parents
   */

  export type AggregateParents = {
    _count: ParentsCountAggregateOutputType | null
    _avg: ParentsAvgAggregateOutputType | null
    _sum: ParentsSumAggregateOutputType | null
    _min: ParentsMinAggregateOutputType | null
    _max: ParentsMaxAggregateOutputType | null
  }

  export type ParentsAvgAggregateOutputType = {
    id: number | null
  }

  export type ParentsSumAggregateOutputType = {
    id: number | null
  }

  export type ParentsMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    password_hash: string | null
    trial_start_date: Date | null
    trial_end_date: Date | null
    is_trial_used: boolean | null
    created_at: Date | null
  }

  export type ParentsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    password_hash: string | null
    trial_start_date: Date | null
    trial_end_date: Date | null
    is_trial_used: boolean | null
    created_at: Date | null
  }

  export type ParentsCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    password_hash: number
    trial_start_date: number
    trial_end_date: number
    is_trial_used: number
    created_at: number
    _all: number
  }


  export type ParentsAvgAggregateInputType = {
    id?: true
  }

  export type ParentsSumAggregateInputType = {
    id?: true
  }

  export type ParentsMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password_hash?: true
    trial_start_date?: true
    trial_end_date?: true
    is_trial_used?: true
    created_at?: true
  }

  export type ParentsMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password_hash?: true
    trial_start_date?: true
    trial_end_date?: true
    is_trial_used?: true
    created_at?: true
  }

  export type ParentsCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password_hash?: true
    trial_start_date?: true
    trial_end_date?: true
    is_trial_used?: true
    created_at?: true
    _all?: true
  }

  export type ParentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parents to aggregate.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parents
    **/
    _count?: true | ParentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentsMaxAggregateInputType
  }

  export type GetParentsAggregateType<T extends ParentsAggregateArgs> = {
        [P in keyof T & keyof AggregateParents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParents[P]>
      : GetScalarType<T[P], AggregateParents[P]>
  }




  export type parentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parentsWhereInput
    orderBy?: parentsOrderByWithAggregationInput | parentsOrderByWithAggregationInput[]
    by: ParentsScalarFieldEnum[] | ParentsScalarFieldEnum
    having?: parentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentsCountAggregateInputType | true
    _avg?: ParentsAvgAggregateInputType
    _sum?: ParentsSumAggregateInputType
    _min?: ParentsMinAggregateInputType
    _max?: ParentsMaxAggregateInputType
  }

  export type ParentsGroupByOutputType = {
    id: number
    name: string
    email: string
    phone: string | null
    password_hash: string
    trial_start_date: Date | null
    trial_end_date: Date | null
    is_trial_used: boolean | null
    created_at: Date | null
    _count: ParentsCountAggregateOutputType | null
    _avg: ParentsAvgAggregateOutputType | null
    _sum: ParentsSumAggregateOutputType | null
    _min: ParentsMinAggregateOutputType | null
    _max: ParentsMaxAggregateOutputType | null
  }

  type GetParentsGroupByPayload<T extends parentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentsGroupByOutputType[P]>
            : GetScalarType<T[P], ParentsGroupByOutputType[P]>
        }
      >
    >


  export type parentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password_hash?: boolean
    trial_start_date?: boolean
    trial_end_date?: boolean
    is_trial_used?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["parents"]>

  export type parentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password_hash?: boolean
    trial_start_date?: boolean
    trial_end_date?: boolean
    is_trial_used?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["parents"]>

  export type parentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password_hash?: boolean
    trial_start_date?: boolean
    trial_end_date?: boolean
    is_trial_used?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["parents"]>

  export type parentsSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password_hash?: boolean
    trial_start_date?: boolean
    trial_end_date?: boolean
    is_trial_used?: boolean
    created_at?: boolean
  }

  export type parentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "password_hash" | "trial_start_date" | "trial_end_date" | "is_trial_used" | "created_at", ExtArgs["result"]["parents"]>

  export type $parentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "parents"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone: string | null
      password_hash: string
      trial_start_date: Date | null
      trial_end_date: Date | null
      is_trial_used: boolean | null
      created_at: Date | null
    }, ExtArgs["result"]["parents"]>
    composites: {}
  }

  type parentsGetPayload<S extends boolean | null | undefined | parentsDefaultArgs> = $Result.GetResult<Prisma.$parentsPayload, S>

  type parentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<parentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentsCountAggregateInputType | true
    }

  export interface parentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parents'], meta: { name: 'parents' } }
    /**
     * Find zero or one Parents that matches the filter.
     * @param {parentsFindUniqueArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends parentsFindUniqueArgs>(args: SelectSubset<T, parentsFindUniqueArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {parentsFindUniqueOrThrowArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends parentsFindUniqueOrThrowArgs>(args: SelectSubset<T, parentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsFindFirstArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends parentsFindFirstArgs>(args?: SelectSubset<T, parentsFindFirstArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsFindFirstOrThrowArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends parentsFindFirstOrThrowArgs>(args?: SelectSubset<T, parentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parents.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentsWithIdOnly = await prisma.parents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends parentsFindManyArgs>(args?: SelectSubset<T, parentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parents.
     * @param {parentsCreateArgs} args - Arguments to create a Parents.
     * @example
     * // Create one Parents
     * const Parents = await prisma.parents.create({
     *   data: {
     *     // ... data to create a Parents
     *   }
     * })
     * 
     */
    create<T extends parentsCreateArgs>(args: SelectSubset<T, parentsCreateArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parents.
     * @param {parentsCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parents = await prisma.parents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends parentsCreateManyArgs>(args?: SelectSubset<T, parentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parents and returns the data saved in the database.
     * @param {parentsCreateManyAndReturnArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parents = await prisma.parents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parents and only return the `id`
     * const parentsWithIdOnly = await prisma.parents.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends parentsCreateManyAndReturnArgs>(args?: SelectSubset<T, parentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parents.
     * @param {parentsDeleteArgs} args - Arguments to delete one Parents.
     * @example
     * // Delete one Parents
     * const Parents = await prisma.parents.delete({
     *   where: {
     *     // ... filter to delete one Parents
     *   }
     * })
     * 
     */
    delete<T extends parentsDeleteArgs>(args: SelectSubset<T, parentsDeleteArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parents.
     * @param {parentsUpdateArgs} args - Arguments to update one Parents.
     * @example
     * // Update one Parents
     * const parents = await prisma.parents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends parentsUpdateArgs>(args: SelectSubset<T, parentsUpdateArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parents.
     * @param {parentsDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends parentsDeleteManyArgs>(args?: SelectSubset<T, parentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parents = await prisma.parents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends parentsUpdateManyArgs>(args: SelectSubset<T, parentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents and returns the data updated in the database.
     * @param {parentsUpdateManyAndReturnArgs} args - Arguments to update many Parents.
     * @example
     * // Update many Parents
     * const parents = await prisma.parents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parents and only return the `id`
     * const parentsWithIdOnly = await prisma.parents.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends parentsUpdateManyAndReturnArgs>(args: SelectSubset<T, parentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parents.
     * @param {parentsUpsertArgs} args - Arguments to update or create a Parents.
     * @example
     * // Update or create a Parents
     * const parents = await prisma.parents.upsert({
     *   create: {
     *     // ... data to create a Parents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parents we want to update
     *   }
     * })
     */
    upsert<T extends parentsUpsertArgs>(args: SelectSubset<T, parentsUpsertArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parents.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends parentsCountArgs>(
      args?: Subset<T, parentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentsAggregateArgs>(args: Subset<T, ParentsAggregateArgs>): Prisma.PrismaPromise<GetParentsAggregateType<T>>

    /**
     * Group by Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parentsGroupByArgs['orderBy'] }
        : { orderBy?: parentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the parents model
   */
  readonly fields: parentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__parentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the parents model
   */
  interface parentsFieldRefs {
    readonly id: FieldRef<"parents", 'Int'>
    readonly name: FieldRef<"parents", 'String'>
    readonly email: FieldRef<"parents", 'String'>
    readonly phone: FieldRef<"parents", 'String'>
    readonly password_hash: FieldRef<"parents", 'String'>
    readonly trial_start_date: FieldRef<"parents", 'DateTime'>
    readonly trial_end_date: FieldRef<"parents", 'DateTime'>
    readonly is_trial_used: FieldRef<"parents", 'Boolean'>
    readonly created_at: FieldRef<"parents", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * parents findUnique
   */
  export type parentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents findUniqueOrThrow
   */
  export type parentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents findFirst
   */
  export type parentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parents.
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parents.
     */
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * parents findFirstOrThrow
   */
  export type parentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parents.
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parents.
     */
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * parents findMany
   */
  export type parentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parents.
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * parents create
   */
  export type parentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * The data needed to create a parents.
     */
    data: XOR<parentsCreateInput, parentsUncheckedCreateInput>
  }

  /**
   * parents createMany
   */
  export type parentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parents.
     */
    data: parentsCreateManyInput | parentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * parents createManyAndReturn
   */
  export type parentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * The data used to create many parents.
     */
    data: parentsCreateManyInput | parentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * parents update
   */
  export type parentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * The data needed to update a parents.
     */
    data: XOR<parentsUpdateInput, parentsUncheckedUpdateInput>
    /**
     * Choose, which parents to update.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents updateMany
   */
  export type parentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parents.
     */
    data: XOR<parentsUpdateManyMutationInput, parentsUncheckedUpdateManyInput>
    /**
     * Filter which parents to update
     */
    where?: parentsWhereInput
    /**
     * Limit how many parents to update.
     */
    limit?: number
  }

  /**
   * parents updateManyAndReturn
   */
  export type parentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * The data used to update parents.
     */
    data: XOR<parentsUpdateManyMutationInput, parentsUncheckedUpdateManyInput>
    /**
     * Filter which parents to update
     */
    where?: parentsWhereInput
    /**
     * Limit how many parents to update.
     */
    limit?: number
  }

  /**
   * parents upsert
   */
  export type parentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * The filter to search for the parents to update in case it exists.
     */
    where: parentsWhereUniqueInput
    /**
     * In case the parents found by the `where` argument doesn't exist, create a new parents with this data.
     */
    create: XOR<parentsCreateInput, parentsUncheckedCreateInput>
    /**
     * In case the parents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parentsUpdateInput, parentsUncheckedUpdateInput>
  }

  /**
   * parents delete
   */
  export type parentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Filter which parents to delete.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents deleteMany
   */
  export type parentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parents to delete
     */
    where?: parentsWhereInput
    /**
     * Limit how many parents to delete.
     */
    limit?: number
  }

  /**
   * parents without action
   */
  export type parentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
  }


  /**
   * Model ChildUser
   */

  export type AggregateChildUser = {
    _count: ChildUserCountAggregateOutputType | null
    _min: ChildUserMinAggregateOutputType | null
    _max: ChildUserMaxAggregateOutputType | null
  }

  export type ChildUserMinAggregateOutputType = {
    id: string | null
    username: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChildUserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChildUserCountAggregateOutputType = {
    id: number
    username: number
    passwordHash: number
    firstName: number
    lastName: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChildUserMinAggregateInputType = {
    id?: true
    username?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChildUserMaxAggregateInputType = {
    id?: true
    username?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChildUserCountAggregateInputType = {
    id?: true
    username?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChildUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChildUser to aggregate.
     */
    where?: ChildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildUsers to fetch.
     */
    orderBy?: ChildUserOrderByWithRelationInput | ChildUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChildUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChildUsers
    **/
    _count?: true | ChildUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChildUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChildUserMaxAggregateInputType
  }

  export type GetChildUserAggregateType<T extends ChildUserAggregateArgs> = {
        [P in keyof T & keyof AggregateChildUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChildUser[P]>
      : GetScalarType<T[P], AggregateChildUser[P]>
  }




  export type ChildUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildUserWhereInput
    orderBy?: ChildUserOrderByWithAggregationInput | ChildUserOrderByWithAggregationInput[]
    by: ChildUserScalarFieldEnum[] | ChildUserScalarFieldEnum
    having?: ChildUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChildUserCountAggregateInputType | true
    _min?: ChildUserMinAggregateInputType
    _max?: ChildUserMaxAggregateInputType
  }

  export type ChildUserGroupByOutputType = {
    id: string
    username: string
    passwordHash: string
    firstName: string | null
    lastName: string | null
    status: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChildUserCountAggregateOutputType | null
    _min: ChildUserMinAggregateOutputType | null
    _max: ChildUserMaxAggregateOutputType | null
  }

  type GetChildUserGroupByPayload<T extends ChildUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChildUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChildUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChildUserGroupByOutputType[P]>
            : GetScalarType<T[P], ChildUserGroupByOutputType[P]>
        }
      >
    >


  export type ChildUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignments?: boolean | ChildUser$assignmentsArgs<ExtArgs>
    _count?: boolean | ChildUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["childUser"]>

  export type ChildUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["childUser"]>

  export type ChildUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["childUser"]>

  export type ChildUserSelectScalar = {
    id?: boolean
    username?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChildUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "passwordHash" | "firstName" | "lastName" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["childUser"]>
  export type ChildUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | ChildUser$assignmentsArgs<ExtArgs>
    _count?: boolean | ChildUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChildUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChildUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChildUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChildUser"
    objects: {
      assignments: Prisma.$ChildAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      passwordHash: string
      firstName: string | null
      lastName: string | null
      status: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["childUser"]>
    composites: {}
  }

  type ChildUserGetPayload<S extends boolean | null | undefined | ChildUserDefaultArgs> = $Result.GetResult<Prisma.$ChildUserPayload, S>

  type ChildUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChildUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChildUserCountAggregateInputType | true
    }

  export interface ChildUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChildUser'], meta: { name: 'ChildUser' } }
    /**
     * Find zero or one ChildUser that matches the filter.
     * @param {ChildUserFindUniqueArgs} args - Arguments to find a ChildUser
     * @example
     * // Get one ChildUser
     * const childUser = await prisma.childUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChildUserFindUniqueArgs>(args: SelectSubset<T, ChildUserFindUniqueArgs<ExtArgs>>): Prisma__ChildUserClient<$Result.GetResult<Prisma.$ChildUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChildUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChildUserFindUniqueOrThrowArgs} args - Arguments to find a ChildUser
     * @example
     * // Get one ChildUser
     * const childUser = await prisma.childUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChildUserFindUniqueOrThrowArgs>(args: SelectSubset<T, ChildUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChildUserClient<$Result.GetResult<Prisma.$ChildUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChildUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildUserFindFirstArgs} args - Arguments to find a ChildUser
     * @example
     * // Get one ChildUser
     * const childUser = await prisma.childUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChildUserFindFirstArgs>(args?: SelectSubset<T, ChildUserFindFirstArgs<ExtArgs>>): Prisma__ChildUserClient<$Result.GetResult<Prisma.$ChildUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChildUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildUserFindFirstOrThrowArgs} args - Arguments to find a ChildUser
     * @example
     * // Get one ChildUser
     * const childUser = await prisma.childUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChildUserFindFirstOrThrowArgs>(args?: SelectSubset<T, ChildUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChildUserClient<$Result.GetResult<Prisma.$ChildUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChildUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChildUsers
     * const childUsers = await prisma.childUser.findMany()
     * 
     * // Get first 10 ChildUsers
     * const childUsers = await prisma.childUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const childUserWithIdOnly = await prisma.childUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChildUserFindManyArgs>(args?: SelectSubset<T, ChildUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChildUser.
     * @param {ChildUserCreateArgs} args - Arguments to create a ChildUser.
     * @example
     * // Create one ChildUser
     * const ChildUser = await prisma.childUser.create({
     *   data: {
     *     // ... data to create a ChildUser
     *   }
     * })
     * 
     */
    create<T extends ChildUserCreateArgs>(args: SelectSubset<T, ChildUserCreateArgs<ExtArgs>>): Prisma__ChildUserClient<$Result.GetResult<Prisma.$ChildUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChildUsers.
     * @param {ChildUserCreateManyArgs} args - Arguments to create many ChildUsers.
     * @example
     * // Create many ChildUsers
     * const childUser = await prisma.childUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChildUserCreateManyArgs>(args?: SelectSubset<T, ChildUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChildUsers and returns the data saved in the database.
     * @param {ChildUserCreateManyAndReturnArgs} args - Arguments to create many ChildUsers.
     * @example
     * // Create many ChildUsers
     * const childUser = await prisma.childUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChildUsers and only return the `id`
     * const childUserWithIdOnly = await prisma.childUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChildUserCreateManyAndReturnArgs>(args?: SelectSubset<T, ChildUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChildUser.
     * @param {ChildUserDeleteArgs} args - Arguments to delete one ChildUser.
     * @example
     * // Delete one ChildUser
     * const ChildUser = await prisma.childUser.delete({
     *   where: {
     *     // ... filter to delete one ChildUser
     *   }
     * })
     * 
     */
    delete<T extends ChildUserDeleteArgs>(args: SelectSubset<T, ChildUserDeleteArgs<ExtArgs>>): Prisma__ChildUserClient<$Result.GetResult<Prisma.$ChildUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChildUser.
     * @param {ChildUserUpdateArgs} args - Arguments to update one ChildUser.
     * @example
     * // Update one ChildUser
     * const childUser = await prisma.childUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChildUserUpdateArgs>(args: SelectSubset<T, ChildUserUpdateArgs<ExtArgs>>): Prisma__ChildUserClient<$Result.GetResult<Prisma.$ChildUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChildUsers.
     * @param {ChildUserDeleteManyArgs} args - Arguments to filter ChildUsers to delete.
     * @example
     * // Delete a few ChildUsers
     * const { count } = await prisma.childUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChildUserDeleteManyArgs>(args?: SelectSubset<T, ChildUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChildUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChildUsers
     * const childUser = await prisma.childUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChildUserUpdateManyArgs>(args: SelectSubset<T, ChildUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChildUsers and returns the data updated in the database.
     * @param {ChildUserUpdateManyAndReturnArgs} args - Arguments to update many ChildUsers.
     * @example
     * // Update many ChildUsers
     * const childUser = await prisma.childUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChildUsers and only return the `id`
     * const childUserWithIdOnly = await prisma.childUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChildUserUpdateManyAndReturnArgs>(args: SelectSubset<T, ChildUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChildUser.
     * @param {ChildUserUpsertArgs} args - Arguments to update or create a ChildUser.
     * @example
     * // Update or create a ChildUser
     * const childUser = await prisma.childUser.upsert({
     *   create: {
     *     // ... data to create a ChildUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChildUser we want to update
     *   }
     * })
     */
    upsert<T extends ChildUserUpsertArgs>(args: SelectSubset<T, ChildUserUpsertArgs<ExtArgs>>): Prisma__ChildUserClient<$Result.GetResult<Prisma.$ChildUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChildUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildUserCountArgs} args - Arguments to filter ChildUsers to count.
     * @example
     * // Count the number of ChildUsers
     * const count = await prisma.childUser.count({
     *   where: {
     *     // ... the filter for the ChildUsers we want to count
     *   }
     * })
    **/
    count<T extends ChildUserCountArgs>(
      args?: Subset<T, ChildUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChildUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChildUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChildUserAggregateArgs>(args: Subset<T, ChildUserAggregateArgs>): Prisma.PrismaPromise<GetChildUserAggregateType<T>>

    /**
     * Group by ChildUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChildUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChildUserGroupByArgs['orderBy'] }
        : { orderBy?: ChildUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChildUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChildUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChildUser model
   */
  readonly fields: ChildUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChildUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChildUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends ChildUser$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ChildUser$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChildUser model
   */
  interface ChildUserFieldRefs {
    readonly id: FieldRef<"ChildUser", 'String'>
    readonly username: FieldRef<"ChildUser", 'String'>
    readonly passwordHash: FieldRef<"ChildUser", 'String'>
    readonly firstName: FieldRef<"ChildUser", 'String'>
    readonly lastName: FieldRef<"ChildUser", 'String'>
    readonly status: FieldRef<"ChildUser", 'String'>
    readonly createdAt: FieldRef<"ChildUser", 'DateTime'>
    readonly updatedAt: FieldRef<"ChildUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChildUser findUnique
   */
  export type ChildUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUser
     */
    select?: ChildUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildUser
     */
    omit?: ChildUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildUserInclude<ExtArgs> | null
    /**
     * Filter, which ChildUser to fetch.
     */
    where: ChildUserWhereUniqueInput
  }

  /**
   * ChildUser findUniqueOrThrow
   */
  export type ChildUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUser
     */
    select?: ChildUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildUser
     */
    omit?: ChildUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildUserInclude<ExtArgs> | null
    /**
     * Filter, which ChildUser to fetch.
     */
    where: ChildUserWhereUniqueInput
  }

  /**
   * ChildUser findFirst
   */
  export type ChildUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUser
     */
    select?: ChildUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildUser
     */
    omit?: ChildUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildUserInclude<ExtArgs> | null
    /**
     * Filter, which ChildUser to fetch.
     */
    where?: ChildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildUsers to fetch.
     */
    orderBy?: ChildUserOrderByWithRelationInput | ChildUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChildUsers.
     */
    cursor?: ChildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChildUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChildUsers.
     */
    distinct?: ChildUserScalarFieldEnum | ChildUserScalarFieldEnum[]
  }

  /**
   * ChildUser findFirstOrThrow
   */
  export type ChildUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUser
     */
    select?: ChildUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildUser
     */
    omit?: ChildUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildUserInclude<ExtArgs> | null
    /**
     * Filter, which ChildUser to fetch.
     */
    where?: ChildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildUsers to fetch.
     */
    orderBy?: ChildUserOrderByWithRelationInput | ChildUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChildUsers.
     */
    cursor?: ChildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChildUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChildUsers.
     */
    distinct?: ChildUserScalarFieldEnum | ChildUserScalarFieldEnum[]
  }

  /**
   * ChildUser findMany
   */
  export type ChildUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUser
     */
    select?: ChildUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildUser
     */
    omit?: ChildUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildUserInclude<ExtArgs> | null
    /**
     * Filter, which ChildUsers to fetch.
     */
    where?: ChildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildUsers to fetch.
     */
    orderBy?: ChildUserOrderByWithRelationInput | ChildUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChildUsers.
     */
    cursor?: ChildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChildUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildUsers.
     */
    skip?: number
    distinct?: ChildUserScalarFieldEnum | ChildUserScalarFieldEnum[]
  }

  /**
   * ChildUser create
   */
  export type ChildUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUser
     */
    select?: ChildUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildUser
     */
    omit?: ChildUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildUserInclude<ExtArgs> | null
    /**
     * The data needed to create a ChildUser.
     */
    data: XOR<ChildUserCreateInput, ChildUserUncheckedCreateInput>
  }

  /**
   * ChildUser createMany
   */
  export type ChildUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChildUsers.
     */
    data: ChildUserCreateManyInput | ChildUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChildUser createManyAndReturn
   */
  export type ChildUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUser
     */
    select?: ChildUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChildUser
     */
    omit?: ChildUserOmit<ExtArgs> | null
    /**
     * The data used to create many ChildUsers.
     */
    data: ChildUserCreateManyInput | ChildUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChildUser update
   */
  export type ChildUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUser
     */
    select?: ChildUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildUser
     */
    omit?: ChildUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildUserInclude<ExtArgs> | null
    /**
     * The data needed to update a ChildUser.
     */
    data: XOR<ChildUserUpdateInput, ChildUserUncheckedUpdateInput>
    /**
     * Choose, which ChildUser to update.
     */
    where: ChildUserWhereUniqueInput
  }

  /**
   * ChildUser updateMany
   */
  export type ChildUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChildUsers.
     */
    data: XOR<ChildUserUpdateManyMutationInput, ChildUserUncheckedUpdateManyInput>
    /**
     * Filter which ChildUsers to update
     */
    where?: ChildUserWhereInput
    /**
     * Limit how many ChildUsers to update.
     */
    limit?: number
  }

  /**
   * ChildUser updateManyAndReturn
   */
  export type ChildUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUser
     */
    select?: ChildUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChildUser
     */
    omit?: ChildUserOmit<ExtArgs> | null
    /**
     * The data used to update ChildUsers.
     */
    data: XOR<ChildUserUpdateManyMutationInput, ChildUserUncheckedUpdateManyInput>
    /**
     * Filter which ChildUsers to update
     */
    where?: ChildUserWhereInput
    /**
     * Limit how many ChildUsers to update.
     */
    limit?: number
  }

  /**
   * ChildUser upsert
   */
  export type ChildUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUser
     */
    select?: ChildUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildUser
     */
    omit?: ChildUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildUserInclude<ExtArgs> | null
    /**
     * The filter to search for the ChildUser to update in case it exists.
     */
    where: ChildUserWhereUniqueInput
    /**
     * In case the ChildUser found by the `where` argument doesn't exist, create a new ChildUser with this data.
     */
    create: XOR<ChildUserCreateInput, ChildUserUncheckedCreateInput>
    /**
     * In case the ChildUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChildUserUpdateInput, ChildUserUncheckedUpdateInput>
  }

  /**
   * ChildUser delete
   */
  export type ChildUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUser
     */
    select?: ChildUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildUser
     */
    omit?: ChildUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildUserInclude<ExtArgs> | null
    /**
     * Filter which ChildUser to delete.
     */
    where: ChildUserWhereUniqueInput
  }

  /**
   * ChildUser deleteMany
   */
  export type ChildUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChildUsers to delete
     */
    where?: ChildUserWhereInput
    /**
     * Limit how many ChildUsers to delete.
     */
    limit?: number
  }

  /**
   * ChildUser.assignments
   */
  export type ChildUser$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentInclude<ExtArgs> | null
    where?: ChildAssignmentWhereInput
    orderBy?: ChildAssignmentOrderByWithRelationInput | ChildAssignmentOrderByWithRelationInput[]
    cursor?: ChildAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChildAssignmentScalarFieldEnum | ChildAssignmentScalarFieldEnum[]
  }

  /**
   * ChildUser without action
   */
  export type ChildUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildUser
     */
    select?: ChildUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildUser
     */
    omit?: ChildUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildUserInclude<ExtArgs> | null
  }


  /**
   * Model ChildAssignment
   */

  export type AggregateChildAssignment = {
    _count: ChildAssignmentCountAggregateOutputType | null
    _min: ChildAssignmentMinAggregateOutputType | null
    _max: ChildAssignmentMaxAggregateOutputType | null
  }

  export type ChildAssignmentMinAggregateOutputType = {
    id: string | null
    childId: string | null
    subject: string | null
    accessCode: string | null
    providerUrl: string | null
    status: $Enums.AssignmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChildAssignmentMaxAggregateOutputType = {
    id: string | null
    childId: string | null
    subject: string | null
    accessCode: string | null
    providerUrl: string | null
    status: $Enums.AssignmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChildAssignmentCountAggregateOutputType = {
    id: number
    childId: number
    subject: number
    accessCode: number
    providerUrl: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChildAssignmentMinAggregateInputType = {
    id?: true
    childId?: true
    subject?: true
    accessCode?: true
    providerUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChildAssignmentMaxAggregateInputType = {
    id?: true
    childId?: true
    subject?: true
    accessCode?: true
    providerUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChildAssignmentCountAggregateInputType = {
    id?: true
    childId?: true
    subject?: true
    accessCode?: true
    providerUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChildAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChildAssignment to aggregate.
     */
    where?: ChildAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildAssignments to fetch.
     */
    orderBy?: ChildAssignmentOrderByWithRelationInput | ChildAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChildAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChildAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChildAssignments
    **/
    _count?: true | ChildAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChildAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChildAssignmentMaxAggregateInputType
  }

  export type GetChildAssignmentAggregateType<T extends ChildAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateChildAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChildAssignment[P]>
      : GetScalarType<T[P], AggregateChildAssignment[P]>
  }




  export type ChildAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildAssignmentWhereInput
    orderBy?: ChildAssignmentOrderByWithAggregationInput | ChildAssignmentOrderByWithAggregationInput[]
    by: ChildAssignmentScalarFieldEnum[] | ChildAssignmentScalarFieldEnum
    having?: ChildAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChildAssignmentCountAggregateInputType | true
    _min?: ChildAssignmentMinAggregateInputType
    _max?: ChildAssignmentMaxAggregateInputType
  }

  export type ChildAssignmentGroupByOutputType = {
    id: string
    childId: string
    subject: string
    accessCode: string
    providerUrl: string
    status: $Enums.AssignmentStatus
    createdAt: Date
    updatedAt: Date
    _count: ChildAssignmentCountAggregateOutputType | null
    _min: ChildAssignmentMinAggregateOutputType | null
    _max: ChildAssignmentMaxAggregateOutputType | null
  }

  type GetChildAssignmentGroupByPayload<T extends ChildAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChildAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChildAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChildAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ChildAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ChildAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    childId?: boolean
    subject?: boolean
    accessCode?: boolean
    providerUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    child?: boolean | ChildUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["childAssignment"]>

  export type ChildAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    childId?: boolean
    subject?: boolean
    accessCode?: boolean
    providerUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    child?: boolean | ChildUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["childAssignment"]>

  export type ChildAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    childId?: boolean
    subject?: boolean
    accessCode?: boolean
    providerUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    child?: boolean | ChildUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["childAssignment"]>

  export type ChildAssignmentSelectScalar = {
    id?: boolean
    childId?: boolean
    subject?: boolean
    accessCode?: boolean
    providerUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChildAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "childId" | "subject" | "accessCode" | "providerUrl" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["childAssignment"]>
  export type ChildAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    child?: boolean | ChildUserDefaultArgs<ExtArgs>
  }
  export type ChildAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    child?: boolean | ChildUserDefaultArgs<ExtArgs>
  }
  export type ChildAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    child?: boolean | ChildUserDefaultArgs<ExtArgs>
  }

  export type $ChildAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChildAssignment"
    objects: {
      child: Prisma.$ChildUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      childId: string
      subject: string
      accessCode: string
      providerUrl: string
      status: $Enums.AssignmentStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["childAssignment"]>
    composites: {}
  }

  type ChildAssignmentGetPayload<S extends boolean | null | undefined | ChildAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ChildAssignmentPayload, S>

  type ChildAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChildAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChildAssignmentCountAggregateInputType | true
    }

  export interface ChildAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChildAssignment'], meta: { name: 'ChildAssignment' } }
    /**
     * Find zero or one ChildAssignment that matches the filter.
     * @param {ChildAssignmentFindUniqueArgs} args - Arguments to find a ChildAssignment
     * @example
     * // Get one ChildAssignment
     * const childAssignment = await prisma.childAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChildAssignmentFindUniqueArgs>(args: SelectSubset<T, ChildAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ChildAssignmentClient<$Result.GetResult<Prisma.$ChildAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChildAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChildAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ChildAssignment
     * @example
     * // Get one ChildAssignment
     * const childAssignment = await prisma.childAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChildAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ChildAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChildAssignmentClient<$Result.GetResult<Prisma.$ChildAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChildAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildAssignmentFindFirstArgs} args - Arguments to find a ChildAssignment
     * @example
     * // Get one ChildAssignment
     * const childAssignment = await prisma.childAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChildAssignmentFindFirstArgs>(args?: SelectSubset<T, ChildAssignmentFindFirstArgs<ExtArgs>>): Prisma__ChildAssignmentClient<$Result.GetResult<Prisma.$ChildAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChildAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildAssignmentFindFirstOrThrowArgs} args - Arguments to find a ChildAssignment
     * @example
     * // Get one ChildAssignment
     * const childAssignment = await prisma.childAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChildAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ChildAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChildAssignmentClient<$Result.GetResult<Prisma.$ChildAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChildAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChildAssignments
     * const childAssignments = await prisma.childAssignment.findMany()
     * 
     * // Get first 10 ChildAssignments
     * const childAssignments = await prisma.childAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const childAssignmentWithIdOnly = await prisma.childAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChildAssignmentFindManyArgs>(args?: SelectSubset<T, ChildAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChildAssignment.
     * @param {ChildAssignmentCreateArgs} args - Arguments to create a ChildAssignment.
     * @example
     * // Create one ChildAssignment
     * const ChildAssignment = await prisma.childAssignment.create({
     *   data: {
     *     // ... data to create a ChildAssignment
     *   }
     * })
     * 
     */
    create<T extends ChildAssignmentCreateArgs>(args: SelectSubset<T, ChildAssignmentCreateArgs<ExtArgs>>): Prisma__ChildAssignmentClient<$Result.GetResult<Prisma.$ChildAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChildAssignments.
     * @param {ChildAssignmentCreateManyArgs} args - Arguments to create many ChildAssignments.
     * @example
     * // Create many ChildAssignments
     * const childAssignment = await prisma.childAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChildAssignmentCreateManyArgs>(args?: SelectSubset<T, ChildAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChildAssignments and returns the data saved in the database.
     * @param {ChildAssignmentCreateManyAndReturnArgs} args - Arguments to create many ChildAssignments.
     * @example
     * // Create many ChildAssignments
     * const childAssignment = await prisma.childAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChildAssignments and only return the `id`
     * const childAssignmentWithIdOnly = await prisma.childAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChildAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ChildAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChildAssignment.
     * @param {ChildAssignmentDeleteArgs} args - Arguments to delete one ChildAssignment.
     * @example
     * // Delete one ChildAssignment
     * const ChildAssignment = await prisma.childAssignment.delete({
     *   where: {
     *     // ... filter to delete one ChildAssignment
     *   }
     * })
     * 
     */
    delete<T extends ChildAssignmentDeleteArgs>(args: SelectSubset<T, ChildAssignmentDeleteArgs<ExtArgs>>): Prisma__ChildAssignmentClient<$Result.GetResult<Prisma.$ChildAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChildAssignment.
     * @param {ChildAssignmentUpdateArgs} args - Arguments to update one ChildAssignment.
     * @example
     * // Update one ChildAssignment
     * const childAssignment = await prisma.childAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChildAssignmentUpdateArgs>(args: SelectSubset<T, ChildAssignmentUpdateArgs<ExtArgs>>): Prisma__ChildAssignmentClient<$Result.GetResult<Prisma.$ChildAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChildAssignments.
     * @param {ChildAssignmentDeleteManyArgs} args - Arguments to filter ChildAssignments to delete.
     * @example
     * // Delete a few ChildAssignments
     * const { count } = await prisma.childAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChildAssignmentDeleteManyArgs>(args?: SelectSubset<T, ChildAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChildAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChildAssignments
     * const childAssignment = await prisma.childAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChildAssignmentUpdateManyArgs>(args: SelectSubset<T, ChildAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChildAssignments and returns the data updated in the database.
     * @param {ChildAssignmentUpdateManyAndReturnArgs} args - Arguments to update many ChildAssignments.
     * @example
     * // Update many ChildAssignments
     * const childAssignment = await prisma.childAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChildAssignments and only return the `id`
     * const childAssignmentWithIdOnly = await prisma.childAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChildAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ChildAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChildAssignment.
     * @param {ChildAssignmentUpsertArgs} args - Arguments to update or create a ChildAssignment.
     * @example
     * // Update or create a ChildAssignment
     * const childAssignment = await prisma.childAssignment.upsert({
     *   create: {
     *     // ... data to create a ChildAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChildAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ChildAssignmentUpsertArgs>(args: SelectSubset<T, ChildAssignmentUpsertArgs<ExtArgs>>): Prisma__ChildAssignmentClient<$Result.GetResult<Prisma.$ChildAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChildAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildAssignmentCountArgs} args - Arguments to filter ChildAssignments to count.
     * @example
     * // Count the number of ChildAssignments
     * const count = await prisma.childAssignment.count({
     *   where: {
     *     // ... the filter for the ChildAssignments we want to count
     *   }
     * })
    **/
    count<T extends ChildAssignmentCountArgs>(
      args?: Subset<T, ChildAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChildAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChildAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChildAssignmentAggregateArgs>(args: Subset<T, ChildAssignmentAggregateArgs>): Prisma.PrismaPromise<GetChildAssignmentAggregateType<T>>

    /**
     * Group by ChildAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChildAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChildAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ChildAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChildAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChildAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChildAssignment model
   */
  readonly fields: ChildAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChildAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChildAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    child<T extends ChildUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChildUserDefaultArgs<ExtArgs>>): Prisma__ChildUserClient<$Result.GetResult<Prisma.$ChildUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChildAssignment model
   */
  interface ChildAssignmentFieldRefs {
    readonly id: FieldRef<"ChildAssignment", 'String'>
    readonly childId: FieldRef<"ChildAssignment", 'String'>
    readonly subject: FieldRef<"ChildAssignment", 'String'>
    readonly accessCode: FieldRef<"ChildAssignment", 'String'>
    readonly providerUrl: FieldRef<"ChildAssignment", 'String'>
    readonly status: FieldRef<"ChildAssignment", 'AssignmentStatus'>
    readonly createdAt: FieldRef<"ChildAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"ChildAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChildAssignment findUnique
   */
  export type ChildAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChildAssignment to fetch.
     */
    where: ChildAssignmentWhereUniqueInput
  }

  /**
   * ChildAssignment findUniqueOrThrow
   */
  export type ChildAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChildAssignment to fetch.
     */
    where: ChildAssignmentWhereUniqueInput
  }

  /**
   * ChildAssignment findFirst
   */
  export type ChildAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChildAssignment to fetch.
     */
    where?: ChildAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildAssignments to fetch.
     */
    orderBy?: ChildAssignmentOrderByWithRelationInput | ChildAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChildAssignments.
     */
    cursor?: ChildAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChildAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChildAssignments.
     */
    distinct?: ChildAssignmentScalarFieldEnum | ChildAssignmentScalarFieldEnum[]
  }

  /**
   * ChildAssignment findFirstOrThrow
   */
  export type ChildAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChildAssignment to fetch.
     */
    where?: ChildAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildAssignments to fetch.
     */
    orderBy?: ChildAssignmentOrderByWithRelationInput | ChildAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChildAssignments.
     */
    cursor?: ChildAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChildAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChildAssignments.
     */
    distinct?: ChildAssignmentScalarFieldEnum | ChildAssignmentScalarFieldEnum[]
  }

  /**
   * ChildAssignment findMany
   */
  export type ChildAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChildAssignments to fetch.
     */
    where?: ChildAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildAssignments to fetch.
     */
    orderBy?: ChildAssignmentOrderByWithRelationInput | ChildAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChildAssignments.
     */
    cursor?: ChildAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChildAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildAssignments.
     */
    skip?: number
    distinct?: ChildAssignmentScalarFieldEnum | ChildAssignmentScalarFieldEnum[]
  }

  /**
   * ChildAssignment create
   */
  export type ChildAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ChildAssignment.
     */
    data: XOR<ChildAssignmentCreateInput, ChildAssignmentUncheckedCreateInput>
  }

  /**
   * ChildAssignment createMany
   */
  export type ChildAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChildAssignments.
     */
    data: ChildAssignmentCreateManyInput | ChildAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChildAssignment createManyAndReturn
   */
  export type ChildAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many ChildAssignments.
     */
    data: ChildAssignmentCreateManyInput | ChildAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChildAssignment update
   */
  export type ChildAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ChildAssignment.
     */
    data: XOR<ChildAssignmentUpdateInput, ChildAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ChildAssignment to update.
     */
    where: ChildAssignmentWhereUniqueInput
  }

  /**
   * ChildAssignment updateMany
   */
  export type ChildAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChildAssignments.
     */
    data: XOR<ChildAssignmentUpdateManyMutationInput, ChildAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ChildAssignments to update
     */
    where?: ChildAssignmentWhereInput
    /**
     * Limit how many ChildAssignments to update.
     */
    limit?: number
  }

  /**
   * ChildAssignment updateManyAndReturn
   */
  export type ChildAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update ChildAssignments.
     */
    data: XOR<ChildAssignmentUpdateManyMutationInput, ChildAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ChildAssignments to update
     */
    where?: ChildAssignmentWhereInput
    /**
     * Limit how many ChildAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChildAssignment upsert
   */
  export type ChildAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ChildAssignment to update in case it exists.
     */
    where: ChildAssignmentWhereUniqueInput
    /**
     * In case the ChildAssignment found by the `where` argument doesn't exist, create a new ChildAssignment with this data.
     */
    create: XOR<ChildAssignmentCreateInput, ChildAssignmentUncheckedCreateInput>
    /**
     * In case the ChildAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChildAssignmentUpdateInput, ChildAssignmentUncheckedUpdateInput>
  }

  /**
   * ChildAssignment delete
   */
  export type ChildAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ChildAssignment to delete.
     */
    where: ChildAssignmentWhereUniqueInput
  }

  /**
   * ChildAssignment deleteMany
   */
  export type ChildAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChildAssignments to delete
     */
    where?: ChildAssignmentWhereInput
    /**
     * Limit how many ChildAssignments to delete.
     */
    limit?: number
  }

  /**
   * ChildAssignment without action
   */
  export type ChildAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildAssignment
     */
    select?: ChildAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChildAssignment
     */
    omit?: ChildAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildAssignmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subscriptionStatus: 'subscriptionStatus',
    trialEndDate: 'trialEndDate',
    trialStartDate: 'trialStartDate'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const Book_detailsScalarFieldEnum: {
    id: 'id',
    isbn: 'isbn',
    overview: 'overview',
    features: 'features',
    contents: 'contents',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Book_detailsScalarFieldEnum = (typeof Book_detailsScalarFieldEnum)[keyof typeof Book_detailsScalarFieldEnum]


  export const BooksScalarFieldEnum: {
    id: 'id',
    title: 'title',
    authors: 'authors',
    subject: 'subject',
    code: 'code',
    edition: 'edition',
    isbn: 'isbn',
    markup: 'markup',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cover_url: 'cover_url',
    category: 'category',
    year: 'year',
    type: 'type',
    price_gbp: 'price_gbp',
    price_ugx: 'price_ugx',
    level: 'level',
    published_date: 'published_date',
    format: 'format',
    has_digital_access: 'has_digital_access',
    publisher: 'publisher',
    grade_year: 'grade_year',
    category_id: 'category_id',
    author: 'author'
  };

  export type BooksScalarFieldEnum = (typeof BooksScalarFieldEnum)[keyof typeof BooksScalarFieldEnum]


  export const Cart_itemsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    book_isbn: 'book_isbn',
    quantity: 'quantity',
    added_at: 'added_at'
  };

  export type Cart_itemsScalarFieldEnum = (typeof Cart_itemsScalarFieldEnum)[keyof typeof Cart_itemsScalarFieldEnum]


  export const Category_lookupScalarFieldEnum: {
    id: 'id',
    category_name: 'category_name'
  };

  export type Category_lookupScalarFieldEnum = (typeof Category_lookupScalarFieldEnum)[keyof typeof Category_lookupScalarFieldEnum]


  export const OrdersScalarFieldEnum: {
    id: 'id',
    parent_name: 'parent_name',
    parent_email: 'parent_email',
    total_ugx: 'total_ugx',
    payment_method: 'payment_method',
    markup_ugx: 'markup_ugx',
    mallory_share: 'mallory_share',
    items_json: 'items_json',
    status: 'status',
    tx_ref: 'tx_ref',
    payment_link: 'payment_link',
    created_at: 'created_at'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const ParentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password_hash: 'password_hash',
    trial_start_date: 'trial_start_date',
    trial_end_date: 'trial_end_date',
    is_trial_used: 'is_trial_used',
    created_at: 'created_at'
  };

  export type ParentsScalarFieldEnum = (typeof ParentsScalarFieldEnum)[keyof typeof ParentsScalarFieldEnum]


  export const ChildUserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChildUserScalarFieldEnum = (typeof ChildUserScalarFieldEnum)[keyof typeof ChildUserScalarFieldEnum]


  export const ChildAssignmentScalarFieldEnum: {
    id: 'id',
    childId: 'childId',
    subject: 'subject',
    accessCode: 'accessCode',
    providerUrl: 'providerUrl',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChildAssignmentScalarFieldEnum = (typeof ChildAssignmentScalarFieldEnum)[keyof typeof ChildAssignmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AssignmentStatus'
   */
  export type EnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus'>
    


  /**
   * Reference to a field of type 'AssignmentStatus[]'
   */
  export type ListEnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    subscriptionStatus?: StringNullableFilter<"User"> | string | null
    trialEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    trialStartDate?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    trialEndDate?: SortOrderInput | SortOrder
    trialStartDate?: SortOrderInput | SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    subscriptionStatus?: StringNullableFilter<"User"> | string | null
    trialEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    trialStartDate?: DateTimeNullableFilter<"User"> | Date | string | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    trialEndDate?: SortOrderInput | SortOrder
    trialStartDate?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    subscriptionStatus?: StringNullableWithAggregatesFilter<"User"> | string | null
    trialEndDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    trialStartDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type book_detailsWhereInput = {
    AND?: book_detailsWhereInput | book_detailsWhereInput[]
    OR?: book_detailsWhereInput[]
    NOT?: book_detailsWhereInput | book_detailsWhereInput[]
    id?: IntFilter<"book_details"> | number
    isbn?: StringNullableFilter<"book_details"> | string | null
    overview?: StringNullableFilter<"book_details"> | string | null
    features?: StringNullableListFilter<"book_details">
    contents?: StringNullableListFilter<"book_details">
    created_at?: DateTimeNullableFilter<"book_details"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"book_details"> | Date | string | null
    books?: XOR<BooksNullableScalarRelationFilter, booksWhereInput> | null
  }

  export type book_detailsOrderByWithRelationInput = {
    id?: SortOrder
    isbn?: SortOrderInput | SortOrder
    overview?: SortOrderInput | SortOrder
    features?: SortOrder
    contents?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    books?: booksOrderByWithRelationInput
  }

  export type book_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    isbn?: string
    AND?: book_detailsWhereInput | book_detailsWhereInput[]
    OR?: book_detailsWhereInput[]
    NOT?: book_detailsWhereInput | book_detailsWhereInput[]
    overview?: StringNullableFilter<"book_details"> | string | null
    features?: StringNullableListFilter<"book_details">
    contents?: StringNullableListFilter<"book_details">
    created_at?: DateTimeNullableFilter<"book_details"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"book_details"> | Date | string | null
    books?: XOR<BooksNullableScalarRelationFilter, booksWhereInput> | null
  }, "id" | "isbn">

  export type book_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    isbn?: SortOrderInput | SortOrder
    overview?: SortOrderInput | SortOrder
    features?: SortOrder
    contents?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: book_detailsCountOrderByAggregateInput
    _avg?: book_detailsAvgOrderByAggregateInput
    _max?: book_detailsMaxOrderByAggregateInput
    _min?: book_detailsMinOrderByAggregateInput
    _sum?: book_detailsSumOrderByAggregateInput
  }

  export type book_detailsScalarWhereWithAggregatesInput = {
    AND?: book_detailsScalarWhereWithAggregatesInput | book_detailsScalarWhereWithAggregatesInput[]
    OR?: book_detailsScalarWhereWithAggregatesInput[]
    NOT?: book_detailsScalarWhereWithAggregatesInput | book_detailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"book_details"> | number
    isbn?: StringNullableWithAggregatesFilter<"book_details"> | string | null
    overview?: StringNullableWithAggregatesFilter<"book_details"> | string | null
    features?: StringNullableListFilter<"book_details">
    contents?: StringNullableListFilter<"book_details">
    created_at?: DateTimeNullableWithAggregatesFilter<"book_details"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"book_details"> | Date | string | null
  }

  export type booksWhereInput = {
    AND?: booksWhereInput | booksWhereInput[]
    OR?: booksWhereInput[]
    NOT?: booksWhereInput | booksWhereInput[]
    id?: IntFilter<"books"> | number
    title?: StringFilter<"books"> | string
    authors?: StringNullableFilter<"books"> | string | null
    subject?: StringNullableFilter<"books"> | string | null
    code?: StringNullableFilter<"books"> | string | null
    edition?: StringNullableFilter<"books"> | string | null
    isbn?: StringNullableFilter<"books"> | string | null
    markup?: FloatNullableFilter<"books"> | number | null
    price?: FloatNullableFilter<"books"> | number | null
    createdAt?: DateTimeFilter<"books"> | Date | string
    updatedAt?: DateTimeNullableFilter<"books"> | Date | string | null
    cover_url?: StringNullableFilter<"books"> | string | null
    category?: StringNullableFilter<"books"> | string | null
    year?: StringNullableFilter<"books"> | string | null
    type?: StringNullableFilter<"books"> | string | null
    price_gbp?: DecimalNullableFilter<"books"> | Decimal | DecimalJsLike | number | string | null
    price_ugx?: DecimalNullableFilter<"books"> | Decimal | DecimalJsLike | number | string | null
    level?: StringNullableFilter<"books"> | string | null
    published_date?: DateTimeNullableFilter<"books"> | Date | string | null
    format?: StringNullableFilter<"books"> | string | null
    has_digital_access?: BoolNullableFilter<"books"> | boolean | null
    publisher?: StringNullableFilter<"books"> | string | null
    grade_year?: StringNullableFilter<"books"> | string | null
    category_id?: IntNullableFilter<"books"> | number | null
    author?: StringNullableFilter<"books"> | string | null
    book_details?: XOR<Book_detailsNullableScalarRelationFilter, book_detailsWhereInput> | null
    category_lookup?: XOR<Category_lookupNullableScalarRelationFilter, category_lookupWhereInput> | null
    cart_items?: Cart_itemsListRelationFilter
  }

  export type booksOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    authors?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    edition?: SortOrderInput | SortOrder
    isbn?: SortOrderInput | SortOrder
    markup?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    cover_url?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    price_gbp?: SortOrderInput | SortOrder
    price_ugx?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    published_date?: SortOrderInput | SortOrder
    format?: SortOrderInput | SortOrder
    has_digital_access?: SortOrderInput | SortOrder
    publisher?: SortOrderInput | SortOrder
    grade_year?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    book_details?: book_detailsOrderByWithRelationInput
    category_lookup?: category_lookupOrderByWithRelationInput
    cart_items?: cart_itemsOrderByRelationAggregateInput
  }

  export type booksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    isbn?: string
    AND?: booksWhereInput | booksWhereInput[]
    OR?: booksWhereInput[]
    NOT?: booksWhereInput | booksWhereInput[]
    title?: StringFilter<"books"> | string
    authors?: StringNullableFilter<"books"> | string | null
    subject?: StringNullableFilter<"books"> | string | null
    code?: StringNullableFilter<"books"> | string | null
    edition?: StringNullableFilter<"books"> | string | null
    markup?: FloatNullableFilter<"books"> | number | null
    price?: FloatNullableFilter<"books"> | number | null
    createdAt?: DateTimeFilter<"books"> | Date | string
    updatedAt?: DateTimeNullableFilter<"books"> | Date | string | null
    cover_url?: StringNullableFilter<"books"> | string | null
    category?: StringNullableFilter<"books"> | string | null
    year?: StringNullableFilter<"books"> | string | null
    type?: StringNullableFilter<"books"> | string | null
    price_gbp?: DecimalNullableFilter<"books"> | Decimal | DecimalJsLike | number | string | null
    price_ugx?: DecimalNullableFilter<"books"> | Decimal | DecimalJsLike | number | string | null
    level?: StringNullableFilter<"books"> | string | null
    published_date?: DateTimeNullableFilter<"books"> | Date | string | null
    format?: StringNullableFilter<"books"> | string | null
    has_digital_access?: BoolNullableFilter<"books"> | boolean | null
    publisher?: StringNullableFilter<"books"> | string | null
    grade_year?: StringNullableFilter<"books"> | string | null
    category_id?: IntNullableFilter<"books"> | number | null
    author?: StringNullableFilter<"books"> | string | null
    book_details?: XOR<Book_detailsNullableScalarRelationFilter, book_detailsWhereInput> | null
    category_lookup?: XOR<Category_lookupNullableScalarRelationFilter, category_lookupWhereInput> | null
    cart_items?: Cart_itemsListRelationFilter
  }, "id" | "isbn">

  export type booksOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    authors?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    edition?: SortOrderInput | SortOrder
    isbn?: SortOrderInput | SortOrder
    markup?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    cover_url?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    price_gbp?: SortOrderInput | SortOrder
    price_ugx?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    published_date?: SortOrderInput | SortOrder
    format?: SortOrderInput | SortOrder
    has_digital_access?: SortOrderInput | SortOrder
    publisher?: SortOrderInput | SortOrder
    grade_year?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    _count?: booksCountOrderByAggregateInput
    _avg?: booksAvgOrderByAggregateInput
    _max?: booksMaxOrderByAggregateInput
    _min?: booksMinOrderByAggregateInput
    _sum?: booksSumOrderByAggregateInput
  }

  export type booksScalarWhereWithAggregatesInput = {
    AND?: booksScalarWhereWithAggregatesInput | booksScalarWhereWithAggregatesInput[]
    OR?: booksScalarWhereWithAggregatesInput[]
    NOT?: booksScalarWhereWithAggregatesInput | booksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"books"> | number
    title?: StringWithAggregatesFilter<"books"> | string
    authors?: StringNullableWithAggregatesFilter<"books"> | string | null
    subject?: StringNullableWithAggregatesFilter<"books"> | string | null
    code?: StringNullableWithAggregatesFilter<"books"> | string | null
    edition?: StringNullableWithAggregatesFilter<"books"> | string | null
    isbn?: StringNullableWithAggregatesFilter<"books"> | string | null
    markup?: FloatNullableWithAggregatesFilter<"books"> | number | null
    price?: FloatNullableWithAggregatesFilter<"books"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"books"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"books"> | Date | string | null
    cover_url?: StringNullableWithAggregatesFilter<"books"> | string | null
    category?: StringNullableWithAggregatesFilter<"books"> | string | null
    year?: StringNullableWithAggregatesFilter<"books"> | string | null
    type?: StringNullableWithAggregatesFilter<"books"> | string | null
    price_gbp?: DecimalNullableWithAggregatesFilter<"books"> | Decimal | DecimalJsLike | number | string | null
    price_ugx?: DecimalNullableWithAggregatesFilter<"books"> | Decimal | DecimalJsLike | number | string | null
    level?: StringNullableWithAggregatesFilter<"books"> | string | null
    published_date?: DateTimeNullableWithAggregatesFilter<"books"> | Date | string | null
    format?: StringNullableWithAggregatesFilter<"books"> | string | null
    has_digital_access?: BoolNullableWithAggregatesFilter<"books"> | boolean | null
    publisher?: StringNullableWithAggregatesFilter<"books"> | string | null
    grade_year?: StringNullableWithAggregatesFilter<"books"> | string | null
    category_id?: IntNullableWithAggregatesFilter<"books"> | number | null
    author?: StringNullableWithAggregatesFilter<"books"> | string | null
  }

  export type cart_itemsWhereInput = {
    AND?: cart_itemsWhereInput | cart_itemsWhereInput[]
    OR?: cart_itemsWhereInput[]
    NOT?: cart_itemsWhereInput | cart_itemsWhereInput[]
    id?: IntFilter<"cart_items"> | number
    user_id?: IntFilter<"cart_items"> | number
    book_isbn?: StringFilter<"cart_items"> | string
    quantity?: IntNullableFilter<"cart_items"> | number | null
    added_at?: DateTimeNullableFilter<"cart_items"> | Date | string | null
    books?: XOR<BooksScalarRelationFilter, booksWhereInput>
  }

  export type cart_itemsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_isbn?: SortOrder
    quantity?: SortOrderInput | SortOrder
    added_at?: SortOrderInput | SortOrder
    books?: booksOrderByWithRelationInput
  }

  export type cart_itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cart_itemsWhereInput | cart_itemsWhereInput[]
    OR?: cart_itemsWhereInput[]
    NOT?: cart_itemsWhereInput | cart_itemsWhereInput[]
    user_id?: IntFilter<"cart_items"> | number
    book_isbn?: StringFilter<"cart_items"> | string
    quantity?: IntNullableFilter<"cart_items"> | number | null
    added_at?: DateTimeNullableFilter<"cart_items"> | Date | string | null
    books?: XOR<BooksScalarRelationFilter, booksWhereInput>
  }, "id">

  export type cart_itemsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_isbn?: SortOrder
    quantity?: SortOrderInput | SortOrder
    added_at?: SortOrderInput | SortOrder
    _count?: cart_itemsCountOrderByAggregateInput
    _avg?: cart_itemsAvgOrderByAggregateInput
    _max?: cart_itemsMaxOrderByAggregateInput
    _min?: cart_itemsMinOrderByAggregateInput
    _sum?: cart_itemsSumOrderByAggregateInput
  }

  export type cart_itemsScalarWhereWithAggregatesInput = {
    AND?: cart_itemsScalarWhereWithAggregatesInput | cart_itemsScalarWhereWithAggregatesInput[]
    OR?: cart_itemsScalarWhereWithAggregatesInput[]
    NOT?: cart_itemsScalarWhereWithAggregatesInput | cart_itemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cart_items"> | number
    user_id?: IntWithAggregatesFilter<"cart_items"> | number
    book_isbn?: StringWithAggregatesFilter<"cart_items"> | string
    quantity?: IntNullableWithAggregatesFilter<"cart_items"> | number | null
    added_at?: DateTimeNullableWithAggregatesFilter<"cart_items"> | Date | string | null
  }

  export type category_lookupWhereInput = {
    AND?: category_lookupWhereInput | category_lookupWhereInput[]
    OR?: category_lookupWhereInput[]
    NOT?: category_lookupWhereInput | category_lookupWhereInput[]
    id?: IntFilter<"category_lookup"> | number
    category_name?: StringFilter<"category_lookup"> | string
    books?: BooksListRelationFilter
  }

  export type category_lookupOrderByWithRelationInput = {
    id?: SortOrder
    category_name?: SortOrder
    books?: booksOrderByRelationAggregateInput
  }

  export type category_lookupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    category_name?: string
    AND?: category_lookupWhereInput | category_lookupWhereInput[]
    OR?: category_lookupWhereInput[]
    NOT?: category_lookupWhereInput | category_lookupWhereInput[]
    books?: BooksListRelationFilter
  }, "id" | "category_name">

  export type category_lookupOrderByWithAggregationInput = {
    id?: SortOrder
    category_name?: SortOrder
    _count?: category_lookupCountOrderByAggregateInput
    _avg?: category_lookupAvgOrderByAggregateInput
    _max?: category_lookupMaxOrderByAggregateInput
    _min?: category_lookupMinOrderByAggregateInput
    _sum?: category_lookupSumOrderByAggregateInput
  }

  export type category_lookupScalarWhereWithAggregatesInput = {
    AND?: category_lookupScalarWhereWithAggregatesInput | category_lookupScalarWhereWithAggregatesInput[]
    OR?: category_lookupScalarWhereWithAggregatesInput[]
    NOT?: category_lookupScalarWhereWithAggregatesInput | category_lookupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"category_lookup"> | number
    category_name?: StringWithAggregatesFilter<"category_lookup"> | string
  }

  export type ordersWhereInput = {
    AND?: ordersWhereInput | ordersWhereInput[]
    OR?: ordersWhereInput[]
    NOT?: ordersWhereInput | ordersWhereInput[]
    id?: IntFilter<"orders"> | number
    parent_name?: StringFilter<"orders"> | string
    parent_email?: StringFilter<"orders"> | string
    total_ugx?: IntFilter<"orders"> | number
    payment_method?: StringFilter<"orders"> | string
    markup_ugx?: IntFilter<"orders"> | number
    mallory_share?: IntFilter<"orders"> | number
    items_json?: StringFilter<"orders"> | string
    status?: StringNullableFilter<"orders"> | string | null
    tx_ref?: StringNullableFilter<"orders"> | string | null
    payment_link?: StringNullableFilter<"orders"> | string | null
    created_at?: DateTimeNullableFilter<"orders"> | Date | string | null
  }

  export type ordersOrderByWithRelationInput = {
    id?: SortOrder
    parent_name?: SortOrder
    parent_email?: SortOrder
    total_ugx?: SortOrder
    payment_method?: SortOrder
    markup_ugx?: SortOrder
    mallory_share?: SortOrder
    items_json?: SortOrder
    status?: SortOrderInput | SortOrder
    tx_ref?: SortOrderInput | SortOrder
    payment_link?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type ordersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tx_ref?: string
    AND?: ordersWhereInput | ordersWhereInput[]
    OR?: ordersWhereInput[]
    NOT?: ordersWhereInput | ordersWhereInput[]
    parent_name?: StringFilter<"orders"> | string
    parent_email?: StringFilter<"orders"> | string
    total_ugx?: IntFilter<"orders"> | number
    payment_method?: StringFilter<"orders"> | string
    markup_ugx?: IntFilter<"orders"> | number
    mallory_share?: IntFilter<"orders"> | number
    items_json?: StringFilter<"orders"> | string
    status?: StringNullableFilter<"orders"> | string | null
    payment_link?: StringNullableFilter<"orders"> | string | null
    created_at?: DateTimeNullableFilter<"orders"> | Date | string | null
  }, "id" | "tx_ref">

  export type ordersOrderByWithAggregationInput = {
    id?: SortOrder
    parent_name?: SortOrder
    parent_email?: SortOrder
    total_ugx?: SortOrder
    payment_method?: SortOrder
    markup_ugx?: SortOrder
    mallory_share?: SortOrder
    items_json?: SortOrder
    status?: SortOrderInput | SortOrder
    tx_ref?: SortOrderInput | SortOrder
    payment_link?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: ordersCountOrderByAggregateInput
    _avg?: ordersAvgOrderByAggregateInput
    _max?: ordersMaxOrderByAggregateInput
    _min?: ordersMinOrderByAggregateInput
    _sum?: ordersSumOrderByAggregateInput
  }

  export type ordersScalarWhereWithAggregatesInput = {
    AND?: ordersScalarWhereWithAggregatesInput | ordersScalarWhereWithAggregatesInput[]
    OR?: ordersScalarWhereWithAggregatesInput[]
    NOT?: ordersScalarWhereWithAggregatesInput | ordersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"orders"> | number
    parent_name?: StringWithAggregatesFilter<"orders"> | string
    parent_email?: StringWithAggregatesFilter<"orders"> | string
    total_ugx?: IntWithAggregatesFilter<"orders"> | number
    payment_method?: StringWithAggregatesFilter<"orders"> | string
    markup_ugx?: IntWithAggregatesFilter<"orders"> | number
    mallory_share?: IntWithAggregatesFilter<"orders"> | number
    items_json?: StringWithAggregatesFilter<"orders"> | string
    status?: StringNullableWithAggregatesFilter<"orders"> | string | null
    tx_ref?: StringNullableWithAggregatesFilter<"orders"> | string | null
    payment_link?: StringNullableWithAggregatesFilter<"orders"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"orders"> | Date | string | null
  }

  export type parentsWhereInput = {
    AND?: parentsWhereInput | parentsWhereInput[]
    OR?: parentsWhereInput[]
    NOT?: parentsWhereInput | parentsWhereInput[]
    id?: IntFilter<"parents"> | number
    name?: StringFilter<"parents"> | string
    email?: StringFilter<"parents"> | string
    phone?: StringNullableFilter<"parents"> | string | null
    password_hash?: StringFilter<"parents"> | string
    trial_start_date?: DateTimeNullableFilter<"parents"> | Date | string | null
    trial_end_date?: DateTimeNullableFilter<"parents"> | Date | string | null
    is_trial_used?: BoolNullableFilter<"parents"> | boolean | null
    created_at?: DateTimeNullableFilter<"parents"> | Date | string | null
  }

  export type parentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password_hash?: SortOrder
    trial_start_date?: SortOrderInput | SortOrder
    trial_end_date?: SortOrderInput | SortOrder
    is_trial_used?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type parentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: parentsWhereInput | parentsWhereInput[]
    OR?: parentsWhereInput[]
    NOT?: parentsWhereInput | parentsWhereInput[]
    name?: StringFilter<"parents"> | string
    phone?: StringNullableFilter<"parents"> | string | null
    password_hash?: StringFilter<"parents"> | string
    trial_start_date?: DateTimeNullableFilter<"parents"> | Date | string | null
    trial_end_date?: DateTimeNullableFilter<"parents"> | Date | string | null
    is_trial_used?: BoolNullableFilter<"parents"> | boolean | null
    created_at?: DateTimeNullableFilter<"parents"> | Date | string | null
  }, "id" | "email">

  export type parentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password_hash?: SortOrder
    trial_start_date?: SortOrderInput | SortOrder
    trial_end_date?: SortOrderInput | SortOrder
    is_trial_used?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: parentsCountOrderByAggregateInput
    _avg?: parentsAvgOrderByAggregateInput
    _max?: parentsMaxOrderByAggregateInput
    _min?: parentsMinOrderByAggregateInput
    _sum?: parentsSumOrderByAggregateInput
  }

  export type parentsScalarWhereWithAggregatesInput = {
    AND?: parentsScalarWhereWithAggregatesInput | parentsScalarWhereWithAggregatesInput[]
    OR?: parentsScalarWhereWithAggregatesInput[]
    NOT?: parentsScalarWhereWithAggregatesInput | parentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"parents"> | number
    name?: StringWithAggregatesFilter<"parents"> | string
    email?: StringWithAggregatesFilter<"parents"> | string
    phone?: StringNullableWithAggregatesFilter<"parents"> | string | null
    password_hash?: StringWithAggregatesFilter<"parents"> | string
    trial_start_date?: DateTimeNullableWithAggregatesFilter<"parents"> | Date | string | null
    trial_end_date?: DateTimeNullableWithAggregatesFilter<"parents"> | Date | string | null
    is_trial_used?: BoolNullableWithAggregatesFilter<"parents"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"parents"> | Date | string | null
  }

  export type ChildUserWhereInput = {
    AND?: ChildUserWhereInput | ChildUserWhereInput[]
    OR?: ChildUserWhereInput[]
    NOT?: ChildUserWhereInput | ChildUserWhereInput[]
    id?: StringFilter<"ChildUser"> | string
    username?: StringFilter<"ChildUser"> | string
    passwordHash?: StringFilter<"ChildUser"> | string
    firstName?: StringNullableFilter<"ChildUser"> | string | null
    lastName?: StringNullableFilter<"ChildUser"> | string | null
    status?: StringNullableFilter<"ChildUser"> | string | null
    createdAt?: DateTimeFilter<"ChildUser"> | Date | string
    updatedAt?: DateTimeFilter<"ChildUser"> | Date | string
    assignments?: ChildAssignmentListRelationFilter
  }

  export type ChildUserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignments?: ChildAssignmentOrderByRelationAggregateInput
  }

  export type ChildUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: ChildUserWhereInput | ChildUserWhereInput[]
    OR?: ChildUserWhereInput[]
    NOT?: ChildUserWhereInput | ChildUserWhereInput[]
    passwordHash?: StringFilter<"ChildUser"> | string
    firstName?: StringNullableFilter<"ChildUser"> | string | null
    lastName?: StringNullableFilter<"ChildUser"> | string | null
    status?: StringNullableFilter<"ChildUser"> | string | null
    createdAt?: DateTimeFilter<"ChildUser"> | Date | string
    updatedAt?: DateTimeFilter<"ChildUser"> | Date | string
    assignments?: ChildAssignmentListRelationFilter
  }, "id" | "username">

  export type ChildUserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChildUserCountOrderByAggregateInput
    _max?: ChildUserMaxOrderByAggregateInput
    _min?: ChildUserMinOrderByAggregateInput
  }

  export type ChildUserScalarWhereWithAggregatesInput = {
    AND?: ChildUserScalarWhereWithAggregatesInput | ChildUserScalarWhereWithAggregatesInput[]
    OR?: ChildUserScalarWhereWithAggregatesInput[]
    NOT?: ChildUserScalarWhereWithAggregatesInput | ChildUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChildUser"> | string
    username?: StringWithAggregatesFilter<"ChildUser"> | string
    passwordHash?: StringWithAggregatesFilter<"ChildUser"> | string
    firstName?: StringNullableWithAggregatesFilter<"ChildUser"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"ChildUser"> | string | null
    status?: StringNullableWithAggregatesFilter<"ChildUser"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChildUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChildUser"> | Date | string
  }

  export type ChildAssignmentWhereInput = {
    AND?: ChildAssignmentWhereInput | ChildAssignmentWhereInput[]
    OR?: ChildAssignmentWhereInput[]
    NOT?: ChildAssignmentWhereInput | ChildAssignmentWhereInput[]
    id?: StringFilter<"ChildAssignment"> | string
    childId?: StringFilter<"ChildAssignment"> | string
    subject?: StringFilter<"ChildAssignment"> | string
    accessCode?: StringFilter<"ChildAssignment"> | string
    providerUrl?: StringFilter<"ChildAssignment"> | string
    status?: EnumAssignmentStatusFilter<"ChildAssignment"> | $Enums.AssignmentStatus
    createdAt?: DateTimeFilter<"ChildAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"ChildAssignment"> | Date | string
    child?: XOR<ChildUserScalarRelationFilter, ChildUserWhereInput>
  }

  export type ChildAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    childId?: SortOrder
    subject?: SortOrder
    accessCode?: SortOrder
    providerUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    child?: ChildUserOrderByWithRelationInput
  }

  export type ChildAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChildAssignmentWhereInput | ChildAssignmentWhereInput[]
    OR?: ChildAssignmentWhereInput[]
    NOT?: ChildAssignmentWhereInput | ChildAssignmentWhereInput[]
    childId?: StringFilter<"ChildAssignment"> | string
    subject?: StringFilter<"ChildAssignment"> | string
    accessCode?: StringFilter<"ChildAssignment"> | string
    providerUrl?: StringFilter<"ChildAssignment"> | string
    status?: EnumAssignmentStatusFilter<"ChildAssignment"> | $Enums.AssignmentStatus
    createdAt?: DateTimeFilter<"ChildAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"ChildAssignment"> | Date | string
    child?: XOR<ChildUserScalarRelationFilter, ChildUserWhereInput>
  }, "id">

  export type ChildAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    childId?: SortOrder
    subject?: SortOrder
    accessCode?: SortOrder
    providerUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChildAssignmentCountOrderByAggregateInput
    _max?: ChildAssignmentMaxOrderByAggregateInput
    _min?: ChildAssignmentMinOrderByAggregateInput
  }

  export type ChildAssignmentScalarWhereWithAggregatesInput = {
    AND?: ChildAssignmentScalarWhereWithAggregatesInput | ChildAssignmentScalarWhereWithAggregatesInput[]
    OR?: ChildAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ChildAssignmentScalarWhereWithAggregatesInput | ChildAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChildAssignment"> | string
    childId?: StringWithAggregatesFilter<"ChildAssignment"> | string
    subject?: StringWithAggregatesFilter<"ChildAssignment"> | string
    accessCode?: StringWithAggregatesFilter<"ChildAssignment"> | string
    providerUrl?: StringWithAggregatesFilter<"ChildAssignment"> | string
    status?: EnumAssignmentStatusWithAggregatesFilter<"ChildAssignment"> | $Enums.AssignmentStatus
    createdAt?: DateTimeWithAggregatesFilter<"ChildAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChildAssignment"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionStatus?: string | null
    trialEndDate?: Date | string | null
    trialStartDate?: Date | string | null
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionStatus?: string | null
    trialEndDate?: Date | string | null
    trialStartDate?: Date | string | null
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionStatus?: string | null
    trialEndDate?: Date | string | null
    trialStartDate?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type book_detailsCreateInput = {
    overview?: string | null
    features?: book_detailsCreatefeaturesInput | string[]
    contents?: book_detailsCreatecontentsInput | string[]
    created_at?: Date | string | null
    updated_at?: Date | string | null
    books?: booksCreateNestedOneWithoutBook_detailsInput
  }

  export type book_detailsUncheckedCreateInput = {
    id?: number
    isbn?: string | null
    overview?: string | null
    features?: book_detailsCreatefeaturesInput | string[]
    contents?: book_detailsCreatecontentsInput | string[]
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type book_detailsUpdateInput = {
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    features?: book_detailsUpdatefeaturesInput | string[]
    contents?: book_detailsUpdatecontentsInput | string[]
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    books?: booksUpdateOneWithoutBook_detailsNestedInput
  }

  export type book_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    features?: book_detailsUpdatefeaturesInput | string[]
    contents?: book_detailsUpdatecontentsInput | string[]
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type book_detailsCreateManyInput = {
    id?: number
    isbn?: string | null
    overview?: string | null
    features?: book_detailsCreatefeaturesInput | string[]
    contents?: book_detailsCreatecontentsInput | string[]
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type book_detailsUpdateManyMutationInput = {
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    features?: book_detailsUpdatefeaturesInput | string[]
    contents?: book_detailsUpdatecontentsInput | string[]
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type book_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    features?: book_detailsUpdatefeaturesInput | string[]
    contents?: book_detailsUpdatecontentsInput | string[]
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type booksCreateInput = {
    title: string
    authors?: string | null
    subject?: string | null
    code?: string | null
    edition?: string | null
    isbn?: string | null
    markup?: number | null
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cover_url?: string | null
    category?: string | null
    year?: string | null
    type?: string | null
    price_gbp?: Decimal | DecimalJsLike | number | string | null
    price_ugx?: Decimal | DecimalJsLike | number | string | null
    level?: string | null
    published_date?: Date | string | null
    format?: string | null
    has_digital_access?: boolean | null
    publisher?: string | null
    grade_year?: string | null
    author?: string | null
    book_details?: book_detailsCreateNestedOneWithoutBooksInput
    category_lookup?: category_lookupCreateNestedOneWithoutBooksInput
    cart_items?: cart_itemsCreateNestedManyWithoutBooksInput
  }

  export type booksUncheckedCreateInput = {
    id?: number
    title: string
    authors?: string | null
    subject?: string | null
    code?: string | null
    edition?: string | null
    isbn?: string | null
    markup?: number | null
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cover_url?: string | null
    category?: string | null
    year?: string | null
    type?: string | null
    price_gbp?: Decimal | DecimalJsLike | number | string | null
    price_ugx?: Decimal | DecimalJsLike | number | string | null
    level?: string | null
    published_date?: Date | string | null
    format?: string | null
    has_digital_access?: boolean | null
    publisher?: string | null
    grade_year?: string | null
    category_id?: number | null
    author?: string | null
    book_details?: book_detailsUncheckedCreateNestedOneWithoutBooksInput
    cart_items?: cart_itemsUncheckedCreateNestedManyWithoutBooksInput
  }

  export type booksUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price_gbp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_ugx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    has_digital_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    book_details?: book_detailsUpdateOneWithoutBooksNestedInput
    category_lookup?: category_lookupUpdateOneWithoutBooksNestedInput
    cart_items?: cart_itemsUpdateManyWithoutBooksNestedInput
  }

  export type booksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price_gbp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_ugx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    has_digital_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    book_details?: book_detailsUncheckedUpdateOneWithoutBooksNestedInput
    cart_items?: cart_itemsUncheckedUpdateManyWithoutBooksNestedInput
  }

  export type booksCreateManyInput = {
    id?: number
    title: string
    authors?: string | null
    subject?: string | null
    code?: string | null
    edition?: string | null
    isbn?: string | null
    markup?: number | null
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cover_url?: string | null
    category?: string | null
    year?: string | null
    type?: string | null
    price_gbp?: Decimal | DecimalJsLike | number | string | null
    price_ugx?: Decimal | DecimalJsLike | number | string | null
    level?: string | null
    published_date?: Date | string | null
    format?: string | null
    has_digital_access?: boolean | null
    publisher?: string | null
    grade_year?: string | null
    category_id?: number | null
    author?: string | null
  }

  export type booksUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price_gbp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_ugx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    has_digital_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type booksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price_gbp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_ugx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    has_digital_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cart_itemsCreateInput = {
    user_id: number
    quantity?: number | null
    added_at?: Date | string | null
    books: booksCreateNestedOneWithoutCart_itemsInput
  }

  export type cart_itemsUncheckedCreateInput = {
    id?: number
    user_id: number
    book_isbn: string
    quantity?: number | null
    added_at?: Date | string | null
  }

  export type cart_itemsUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    books?: booksUpdateOneRequiredWithoutCart_itemsNestedInput
  }

  export type cart_itemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    book_isbn?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cart_itemsCreateManyInput = {
    id?: number
    user_id: number
    book_isbn: string
    quantity?: number | null
    added_at?: Date | string | null
  }

  export type cart_itemsUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cart_itemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    book_isbn?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type category_lookupCreateInput = {
    category_name: string
    books?: booksCreateNestedManyWithoutCategory_lookupInput
  }

  export type category_lookupUncheckedCreateInput = {
    id?: number
    category_name: string
    books?: booksUncheckedCreateNestedManyWithoutCategory_lookupInput
  }

  export type category_lookupUpdateInput = {
    category_name?: StringFieldUpdateOperationsInput | string
    books?: booksUpdateManyWithoutCategory_lookupNestedInput
  }

  export type category_lookupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
    books?: booksUncheckedUpdateManyWithoutCategory_lookupNestedInput
  }

  export type category_lookupCreateManyInput = {
    id?: number
    category_name: string
  }

  export type category_lookupUpdateManyMutationInput = {
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type category_lookupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type ordersCreateInput = {
    parent_name: string
    parent_email: string
    total_ugx: number
    payment_method: string
    markup_ugx: number
    mallory_share: number
    items_json: string
    status?: string | null
    tx_ref?: string | null
    payment_link?: string | null
    created_at?: Date | string | null
  }

  export type ordersUncheckedCreateInput = {
    id?: number
    parent_name: string
    parent_email: string
    total_ugx: number
    payment_method: string
    markup_ugx: number
    mallory_share: number
    items_json: string
    status?: string | null
    tx_ref?: string | null
    payment_link?: string | null
    created_at?: Date | string | null
  }

  export type ordersUpdateInput = {
    parent_name?: StringFieldUpdateOperationsInput | string
    parent_email?: StringFieldUpdateOperationsInput | string
    total_ugx?: IntFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    markup_ugx?: IntFieldUpdateOperationsInput | number
    mallory_share?: IntFieldUpdateOperationsInput | number
    items_json?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tx_ref?: NullableStringFieldUpdateOperationsInput | string | null
    payment_link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ordersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_name?: StringFieldUpdateOperationsInput | string
    parent_email?: StringFieldUpdateOperationsInput | string
    total_ugx?: IntFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    markup_ugx?: IntFieldUpdateOperationsInput | number
    mallory_share?: IntFieldUpdateOperationsInput | number
    items_json?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tx_ref?: NullableStringFieldUpdateOperationsInput | string | null
    payment_link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ordersCreateManyInput = {
    id?: number
    parent_name: string
    parent_email: string
    total_ugx: number
    payment_method: string
    markup_ugx: number
    mallory_share: number
    items_json: string
    status?: string | null
    tx_ref?: string | null
    payment_link?: string | null
    created_at?: Date | string | null
  }

  export type ordersUpdateManyMutationInput = {
    parent_name?: StringFieldUpdateOperationsInput | string
    parent_email?: StringFieldUpdateOperationsInput | string
    total_ugx?: IntFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    markup_ugx?: IntFieldUpdateOperationsInput | number
    mallory_share?: IntFieldUpdateOperationsInput | number
    items_json?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tx_ref?: NullableStringFieldUpdateOperationsInput | string | null
    payment_link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ordersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_name?: StringFieldUpdateOperationsInput | string
    parent_email?: StringFieldUpdateOperationsInput | string
    total_ugx?: IntFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    markup_ugx?: IntFieldUpdateOperationsInput | number
    mallory_share?: IntFieldUpdateOperationsInput | number
    items_json?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tx_ref?: NullableStringFieldUpdateOperationsInput | string | null
    payment_link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type parentsCreateInput = {
    name: string
    email: string
    phone?: string | null
    password_hash: string
    trial_start_date?: Date | string | null
    trial_end_date?: Date | string | null
    is_trial_used?: boolean | null
    created_at?: Date | string | null
  }

  export type parentsUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    password_hash: string
    trial_start_date?: Date | string | null
    trial_end_date?: Date | string | null
    is_trial_used?: boolean | null
    created_at?: Date | string | null
  }

  export type parentsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    trial_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_trial_used?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type parentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    trial_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_trial_used?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type parentsCreateManyInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    password_hash: string
    trial_start_date?: Date | string | null
    trial_end_date?: Date | string | null
    is_trial_used?: boolean | null
    created_at?: Date | string | null
  }

  export type parentsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    trial_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_trial_used?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type parentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    trial_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_trial_used?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChildUserCreateInput = {
    id?: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ChildAssignmentCreateNestedManyWithoutChildInput
  }

  export type ChildUserUncheckedCreateInput = {
    id?: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ChildAssignmentUncheckedCreateNestedManyWithoutChildInput
  }

  export type ChildUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ChildAssignmentUpdateManyWithoutChildNestedInput
  }

  export type ChildUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ChildAssignmentUncheckedUpdateManyWithoutChildNestedInput
  }

  export type ChildUserCreateManyInput = {
    id?: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChildUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildAssignmentCreateInput = {
    id?: string
    subject: string
    accessCode: string
    providerUrl: string
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    child: ChildUserCreateNestedOneWithoutAssignmentsInput
  }

  export type ChildAssignmentUncheckedCreateInput = {
    id?: string
    childId: string
    subject: string
    accessCode: string
    providerUrl: string
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChildAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    providerUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    child?: ChildUserUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type ChildAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    childId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    providerUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildAssignmentCreateManyInput = {
    id?: string
    childId: string
    subject: string
    accessCode: string
    providerUrl: string
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChildAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    providerUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    childId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    providerUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptionStatus?: SortOrder
    trialEndDate?: SortOrder
    trialStartDate?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptionStatus?: SortOrder
    trialEndDate?: SortOrder
    trialStartDate?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptionStatus?: SortOrder
    trialEndDate?: SortOrder
    trialStartDate?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BooksNullableScalarRelationFilter = {
    is?: booksWhereInput | null
    isNot?: booksWhereInput | null
  }

  export type book_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    isbn?: SortOrder
    overview?: SortOrder
    features?: SortOrder
    contents?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type book_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type book_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    isbn?: SortOrder
    overview?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type book_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    isbn?: SortOrder
    overview?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type book_detailsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Book_detailsNullableScalarRelationFilter = {
    is?: book_detailsWhereInput | null
    isNot?: book_detailsWhereInput | null
  }

  export type Category_lookupNullableScalarRelationFilter = {
    is?: category_lookupWhereInput | null
    isNot?: category_lookupWhereInput | null
  }

  export type Cart_itemsListRelationFilter = {
    every?: cart_itemsWhereInput
    some?: cart_itemsWhereInput
    none?: cart_itemsWhereInput
  }

  export type cart_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type booksCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    authors?: SortOrder
    subject?: SortOrder
    code?: SortOrder
    edition?: SortOrder
    isbn?: SortOrder
    markup?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cover_url?: SortOrder
    category?: SortOrder
    year?: SortOrder
    type?: SortOrder
    price_gbp?: SortOrder
    price_ugx?: SortOrder
    level?: SortOrder
    published_date?: SortOrder
    format?: SortOrder
    has_digital_access?: SortOrder
    publisher?: SortOrder
    grade_year?: SortOrder
    category_id?: SortOrder
    author?: SortOrder
  }

  export type booksAvgOrderByAggregateInput = {
    id?: SortOrder
    markup?: SortOrder
    price?: SortOrder
    price_gbp?: SortOrder
    price_ugx?: SortOrder
    category_id?: SortOrder
  }

  export type booksMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    authors?: SortOrder
    subject?: SortOrder
    code?: SortOrder
    edition?: SortOrder
    isbn?: SortOrder
    markup?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cover_url?: SortOrder
    category?: SortOrder
    year?: SortOrder
    type?: SortOrder
    price_gbp?: SortOrder
    price_ugx?: SortOrder
    level?: SortOrder
    published_date?: SortOrder
    format?: SortOrder
    has_digital_access?: SortOrder
    publisher?: SortOrder
    grade_year?: SortOrder
    category_id?: SortOrder
    author?: SortOrder
  }

  export type booksMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    authors?: SortOrder
    subject?: SortOrder
    code?: SortOrder
    edition?: SortOrder
    isbn?: SortOrder
    markup?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cover_url?: SortOrder
    category?: SortOrder
    year?: SortOrder
    type?: SortOrder
    price_gbp?: SortOrder
    price_ugx?: SortOrder
    level?: SortOrder
    published_date?: SortOrder
    format?: SortOrder
    has_digital_access?: SortOrder
    publisher?: SortOrder
    grade_year?: SortOrder
    category_id?: SortOrder
    author?: SortOrder
  }

  export type booksSumOrderByAggregateInput = {
    id?: SortOrder
    markup?: SortOrder
    price?: SortOrder
    price_gbp?: SortOrder
    price_ugx?: SortOrder
    category_id?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BooksScalarRelationFilter = {
    is?: booksWhereInput
    isNot?: booksWhereInput
  }

  export type cart_itemsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_isbn?: SortOrder
    quantity?: SortOrder
    added_at?: SortOrder
  }

  export type cart_itemsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    quantity?: SortOrder
  }

  export type cart_itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_isbn?: SortOrder
    quantity?: SortOrder
    added_at?: SortOrder
  }

  export type cart_itemsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    book_isbn?: SortOrder
    quantity?: SortOrder
    added_at?: SortOrder
  }

  export type cart_itemsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    quantity?: SortOrder
  }

  export type BooksListRelationFilter = {
    every?: booksWhereInput
    some?: booksWhereInput
    none?: booksWhereInput
  }

  export type booksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type category_lookupCountOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
  }

  export type category_lookupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type category_lookupMaxOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
  }

  export type category_lookupMinOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
  }

  export type category_lookupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ordersCountOrderByAggregateInput = {
    id?: SortOrder
    parent_name?: SortOrder
    parent_email?: SortOrder
    total_ugx?: SortOrder
    payment_method?: SortOrder
    markup_ugx?: SortOrder
    mallory_share?: SortOrder
    items_json?: SortOrder
    status?: SortOrder
    tx_ref?: SortOrder
    payment_link?: SortOrder
    created_at?: SortOrder
  }

  export type ordersAvgOrderByAggregateInput = {
    id?: SortOrder
    total_ugx?: SortOrder
    markup_ugx?: SortOrder
    mallory_share?: SortOrder
  }

  export type ordersMaxOrderByAggregateInput = {
    id?: SortOrder
    parent_name?: SortOrder
    parent_email?: SortOrder
    total_ugx?: SortOrder
    payment_method?: SortOrder
    markup_ugx?: SortOrder
    mallory_share?: SortOrder
    items_json?: SortOrder
    status?: SortOrder
    tx_ref?: SortOrder
    payment_link?: SortOrder
    created_at?: SortOrder
  }

  export type ordersMinOrderByAggregateInput = {
    id?: SortOrder
    parent_name?: SortOrder
    parent_email?: SortOrder
    total_ugx?: SortOrder
    payment_method?: SortOrder
    markup_ugx?: SortOrder
    mallory_share?: SortOrder
    items_json?: SortOrder
    status?: SortOrder
    tx_ref?: SortOrder
    payment_link?: SortOrder
    created_at?: SortOrder
  }

  export type ordersSumOrderByAggregateInput = {
    id?: SortOrder
    total_ugx?: SortOrder
    markup_ugx?: SortOrder
    mallory_share?: SortOrder
  }

  export type parentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password_hash?: SortOrder
    trial_start_date?: SortOrder
    trial_end_date?: SortOrder
    is_trial_used?: SortOrder
    created_at?: SortOrder
  }

  export type parentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type parentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password_hash?: SortOrder
    trial_start_date?: SortOrder
    trial_end_date?: SortOrder
    is_trial_used?: SortOrder
    created_at?: SortOrder
  }

  export type parentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password_hash?: SortOrder
    trial_start_date?: SortOrder
    trial_end_date?: SortOrder
    is_trial_used?: SortOrder
    created_at?: SortOrder
  }

  export type parentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChildAssignmentListRelationFilter = {
    every?: ChildAssignmentWhereInput
    some?: ChildAssignmentWhereInput
    none?: ChildAssignmentWhereInput
  }

  export type ChildAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChildUserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChildUserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChildUserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type ChildUserScalarRelationFilter = {
    is?: ChildUserWhereInput
    isNot?: ChildUserWhereInput
  }

  export type ChildAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    childId?: SortOrder
    subject?: SortOrder
    accessCode?: SortOrder
    providerUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChildAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    childId?: SortOrder
    subject?: SortOrder
    accessCode?: SortOrder
    providerUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChildAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    childId?: SortOrder
    subject?: SortOrder
    accessCode?: SortOrder
    providerUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type book_detailsCreatefeaturesInput = {
    set: string[]
  }

  export type book_detailsCreatecontentsInput = {
    set: string[]
  }

  export type booksCreateNestedOneWithoutBook_detailsInput = {
    create?: XOR<booksCreateWithoutBook_detailsInput, booksUncheckedCreateWithoutBook_detailsInput>
    connectOrCreate?: booksCreateOrConnectWithoutBook_detailsInput
    connect?: booksWhereUniqueInput
  }

  export type book_detailsUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type book_detailsUpdatecontentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type booksUpdateOneWithoutBook_detailsNestedInput = {
    create?: XOR<booksCreateWithoutBook_detailsInput, booksUncheckedCreateWithoutBook_detailsInput>
    connectOrCreate?: booksCreateOrConnectWithoutBook_detailsInput
    upsert?: booksUpsertWithoutBook_detailsInput
    disconnect?: booksWhereInput | boolean
    delete?: booksWhereInput | boolean
    connect?: booksWhereUniqueInput
    update?: XOR<XOR<booksUpdateToOneWithWhereWithoutBook_detailsInput, booksUpdateWithoutBook_detailsInput>, booksUncheckedUpdateWithoutBook_detailsInput>
  }

  export type book_detailsCreateNestedOneWithoutBooksInput = {
    create?: XOR<book_detailsCreateWithoutBooksInput, book_detailsUncheckedCreateWithoutBooksInput>
    connectOrCreate?: book_detailsCreateOrConnectWithoutBooksInput
    connect?: book_detailsWhereUniqueInput
  }

  export type category_lookupCreateNestedOneWithoutBooksInput = {
    create?: XOR<category_lookupCreateWithoutBooksInput, category_lookupUncheckedCreateWithoutBooksInput>
    connectOrCreate?: category_lookupCreateOrConnectWithoutBooksInput
    connect?: category_lookupWhereUniqueInput
  }

  export type cart_itemsCreateNestedManyWithoutBooksInput = {
    create?: XOR<cart_itemsCreateWithoutBooksInput, cart_itemsUncheckedCreateWithoutBooksInput> | cart_itemsCreateWithoutBooksInput[] | cart_itemsUncheckedCreateWithoutBooksInput[]
    connectOrCreate?: cart_itemsCreateOrConnectWithoutBooksInput | cart_itemsCreateOrConnectWithoutBooksInput[]
    createMany?: cart_itemsCreateManyBooksInputEnvelope
    connect?: cart_itemsWhereUniqueInput | cart_itemsWhereUniqueInput[]
  }

  export type book_detailsUncheckedCreateNestedOneWithoutBooksInput = {
    create?: XOR<book_detailsCreateWithoutBooksInput, book_detailsUncheckedCreateWithoutBooksInput>
    connectOrCreate?: book_detailsCreateOrConnectWithoutBooksInput
    connect?: book_detailsWhereUniqueInput
  }

  export type cart_itemsUncheckedCreateNestedManyWithoutBooksInput = {
    create?: XOR<cart_itemsCreateWithoutBooksInput, cart_itemsUncheckedCreateWithoutBooksInput> | cart_itemsCreateWithoutBooksInput[] | cart_itemsUncheckedCreateWithoutBooksInput[]
    connectOrCreate?: cart_itemsCreateOrConnectWithoutBooksInput | cart_itemsCreateOrConnectWithoutBooksInput[]
    createMany?: cart_itemsCreateManyBooksInputEnvelope
    connect?: cart_itemsWhereUniqueInput | cart_itemsWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type book_detailsUpdateOneWithoutBooksNestedInput = {
    create?: XOR<book_detailsCreateWithoutBooksInput, book_detailsUncheckedCreateWithoutBooksInput>
    connectOrCreate?: book_detailsCreateOrConnectWithoutBooksInput
    upsert?: book_detailsUpsertWithoutBooksInput
    disconnect?: book_detailsWhereInput | boolean
    delete?: book_detailsWhereInput | boolean
    connect?: book_detailsWhereUniqueInput
    update?: XOR<XOR<book_detailsUpdateToOneWithWhereWithoutBooksInput, book_detailsUpdateWithoutBooksInput>, book_detailsUncheckedUpdateWithoutBooksInput>
  }

  export type category_lookupUpdateOneWithoutBooksNestedInput = {
    create?: XOR<category_lookupCreateWithoutBooksInput, category_lookupUncheckedCreateWithoutBooksInput>
    connectOrCreate?: category_lookupCreateOrConnectWithoutBooksInput
    upsert?: category_lookupUpsertWithoutBooksInput
    disconnect?: category_lookupWhereInput | boolean
    delete?: category_lookupWhereInput | boolean
    connect?: category_lookupWhereUniqueInput
    update?: XOR<XOR<category_lookupUpdateToOneWithWhereWithoutBooksInput, category_lookupUpdateWithoutBooksInput>, category_lookupUncheckedUpdateWithoutBooksInput>
  }

  export type cart_itemsUpdateManyWithoutBooksNestedInput = {
    create?: XOR<cart_itemsCreateWithoutBooksInput, cart_itemsUncheckedCreateWithoutBooksInput> | cart_itemsCreateWithoutBooksInput[] | cart_itemsUncheckedCreateWithoutBooksInput[]
    connectOrCreate?: cart_itemsCreateOrConnectWithoutBooksInput | cart_itemsCreateOrConnectWithoutBooksInput[]
    upsert?: cart_itemsUpsertWithWhereUniqueWithoutBooksInput | cart_itemsUpsertWithWhereUniqueWithoutBooksInput[]
    createMany?: cart_itemsCreateManyBooksInputEnvelope
    set?: cart_itemsWhereUniqueInput | cart_itemsWhereUniqueInput[]
    disconnect?: cart_itemsWhereUniqueInput | cart_itemsWhereUniqueInput[]
    delete?: cart_itemsWhereUniqueInput | cart_itemsWhereUniqueInput[]
    connect?: cart_itemsWhereUniqueInput | cart_itemsWhereUniqueInput[]
    update?: cart_itemsUpdateWithWhereUniqueWithoutBooksInput | cart_itemsUpdateWithWhereUniqueWithoutBooksInput[]
    updateMany?: cart_itemsUpdateManyWithWhereWithoutBooksInput | cart_itemsUpdateManyWithWhereWithoutBooksInput[]
    deleteMany?: cart_itemsScalarWhereInput | cart_itemsScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type book_detailsUncheckedUpdateOneWithoutBooksNestedInput = {
    create?: XOR<book_detailsCreateWithoutBooksInput, book_detailsUncheckedCreateWithoutBooksInput>
    connectOrCreate?: book_detailsCreateOrConnectWithoutBooksInput
    upsert?: book_detailsUpsertWithoutBooksInput
    disconnect?: book_detailsWhereInput | boolean
    delete?: book_detailsWhereInput | boolean
    connect?: book_detailsWhereUniqueInput
    update?: XOR<XOR<book_detailsUpdateToOneWithWhereWithoutBooksInput, book_detailsUpdateWithoutBooksInput>, book_detailsUncheckedUpdateWithoutBooksInput>
  }

  export type cart_itemsUncheckedUpdateManyWithoutBooksNestedInput = {
    create?: XOR<cart_itemsCreateWithoutBooksInput, cart_itemsUncheckedCreateWithoutBooksInput> | cart_itemsCreateWithoutBooksInput[] | cart_itemsUncheckedCreateWithoutBooksInput[]
    connectOrCreate?: cart_itemsCreateOrConnectWithoutBooksInput | cart_itemsCreateOrConnectWithoutBooksInput[]
    upsert?: cart_itemsUpsertWithWhereUniqueWithoutBooksInput | cart_itemsUpsertWithWhereUniqueWithoutBooksInput[]
    createMany?: cart_itemsCreateManyBooksInputEnvelope
    set?: cart_itemsWhereUniqueInput | cart_itemsWhereUniqueInput[]
    disconnect?: cart_itemsWhereUniqueInput | cart_itemsWhereUniqueInput[]
    delete?: cart_itemsWhereUniqueInput | cart_itemsWhereUniqueInput[]
    connect?: cart_itemsWhereUniqueInput | cart_itemsWhereUniqueInput[]
    update?: cart_itemsUpdateWithWhereUniqueWithoutBooksInput | cart_itemsUpdateWithWhereUniqueWithoutBooksInput[]
    updateMany?: cart_itemsUpdateManyWithWhereWithoutBooksInput | cart_itemsUpdateManyWithWhereWithoutBooksInput[]
    deleteMany?: cart_itemsScalarWhereInput | cart_itemsScalarWhereInput[]
  }

  export type booksCreateNestedOneWithoutCart_itemsInput = {
    create?: XOR<booksCreateWithoutCart_itemsInput, booksUncheckedCreateWithoutCart_itemsInput>
    connectOrCreate?: booksCreateOrConnectWithoutCart_itemsInput
    connect?: booksWhereUniqueInput
  }

  export type booksUpdateOneRequiredWithoutCart_itemsNestedInput = {
    create?: XOR<booksCreateWithoutCart_itemsInput, booksUncheckedCreateWithoutCart_itemsInput>
    connectOrCreate?: booksCreateOrConnectWithoutCart_itemsInput
    upsert?: booksUpsertWithoutCart_itemsInput
    connect?: booksWhereUniqueInput
    update?: XOR<XOR<booksUpdateToOneWithWhereWithoutCart_itemsInput, booksUpdateWithoutCart_itemsInput>, booksUncheckedUpdateWithoutCart_itemsInput>
  }

  export type booksCreateNestedManyWithoutCategory_lookupInput = {
    create?: XOR<booksCreateWithoutCategory_lookupInput, booksUncheckedCreateWithoutCategory_lookupInput> | booksCreateWithoutCategory_lookupInput[] | booksUncheckedCreateWithoutCategory_lookupInput[]
    connectOrCreate?: booksCreateOrConnectWithoutCategory_lookupInput | booksCreateOrConnectWithoutCategory_lookupInput[]
    createMany?: booksCreateManyCategory_lookupInputEnvelope
    connect?: booksWhereUniqueInput | booksWhereUniqueInput[]
  }

  export type booksUncheckedCreateNestedManyWithoutCategory_lookupInput = {
    create?: XOR<booksCreateWithoutCategory_lookupInput, booksUncheckedCreateWithoutCategory_lookupInput> | booksCreateWithoutCategory_lookupInput[] | booksUncheckedCreateWithoutCategory_lookupInput[]
    connectOrCreate?: booksCreateOrConnectWithoutCategory_lookupInput | booksCreateOrConnectWithoutCategory_lookupInput[]
    createMany?: booksCreateManyCategory_lookupInputEnvelope
    connect?: booksWhereUniqueInput | booksWhereUniqueInput[]
  }

  export type booksUpdateManyWithoutCategory_lookupNestedInput = {
    create?: XOR<booksCreateWithoutCategory_lookupInput, booksUncheckedCreateWithoutCategory_lookupInput> | booksCreateWithoutCategory_lookupInput[] | booksUncheckedCreateWithoutCategory_lookupInput[]
    connectOrCreate?: booksCreateOrConnectWithoutCategory_lookupInput | booksCreateOrConnectWithoutCategory_lookupInput[]
    upsert?: booksUpsertWithWhereUniqueWithoutCategory_lookupInput | booksUpsertWithWhereUniqueWithoutCategory_lookupInput[]
    createMany?: booksCreateManyCategory_lookupInputEnvelope
    set?: booksWhereUniqueInput | booksWhereUniqueInput[]
    disconnect?: booksWhereUniqueInput | booksWhereUniqueInput[]
    delete?: booksWhereUniqueInput | booksWhereUniqueInput[]
    connect?: booksWhereUniqueInput | booksWhereUniqueInput[]
    update?: booksUpdateWithWhereUniqueWithoutCategory_lookupInput | booksUpdateWithWhereUniqueWithoutCategory_lookupInput[]
    updateMany?: booksUpdateManyWithWhereWithoutCategory_lookupInput | booksUpdateManyWithWhereWithoutCategory_lookupInput[]
    deleteMany?: booksScalarWhereInput | booksScalarWhereInput[]
  }

  export type booksUncheckedUpdateManyWithoutCategory_lookupNestedInput = {
    create?: XOR<booksCreateWithoutCategory_lookupInput, booksUncheckedCreateWithoutCategory_lookupInput> | booksCreateWithoutCategory_lookupInput[] | booksUncheckedCreateWithoutCategory_lookupInput[]
    connectOrCreate?: booksCreateOrConnectWithoutCategory_lookupInput | booksCreateOrConnectWithoutCategory_lookupInput[]
    upsert?: booksUpsertWithWhereUniqueWithoutCategory_lookupInput | booksUpsertWithWhereUniqueWithoutCategory_lookupInput[]
    createMany?: booksCreateManyCategory_lookupInputEnvelope
    set?: booksWhereUniqueInput | booksWhereUniqueInput[]
    disconnect?: booksWhereUniqueInput | booksWhereUniqueInput[]
    delete?: booksWhereUniqueInput | booksWhereUniqueInput[]
    connect?: booksWhereUniqueInput | booksWhereUniqueInput[]
    update?: booksUpdateWithWhereUniqueWithoutCategory_lookupInput | booksUpdateWithWhereUniqueWithoutCategory_lookupInput[]
    updateMany?: booksUpdateManyWithWhereWithoutCategory_lookupInput | booksUpdateManyWithWhereWithoutCategory_lookupInput[]
    deleteMany?: booksScalarWhereInput | booksScalarWhereInput[]
  }

  export type ChildAssignmentCreateNestedManyWithoutChildInput = {
    create?: XOR<ChildAssignmentCreateWithoutChildInput, ChildAssignmentUncheckedCreateWithoutChildInput> | ChildAssignmentCreateWithoutChildInput[] | ChildAssignmentUncheckedCreateWithoutChildInput[]
    connectOrCreate?: ChildAssignmentCreateOrConnectWithoutChildInput | ChildAssignmentCreateOrConnectWithoutChildInput[]
    createMany?: ChildAssignmentCreateManyChildInputEnvelope
    connect?: ChildAssignmentWhereUniqueInput | ChildAssignmentWhereUniqueInput[]
  }

  export type ChildAssignmentUncheckedCreateNestedManyWithoutChildInput = {
    create?: XOR<ChildAssignmentCreateWithoutChildInput, ChildAssignmentUncheckedCreateWithoutChildInput> | ChildAssignmentCreateWithoutChildInput[] | ChildAssignmentUncheckedCreateWithoutChildInput[]
    connectOrCreate?: ChildAssignmentCreateOrConnectWithoutChildInput | ChildAssignmentCreateOrConnectWithoutChildInput[]
    createMany?: ChildAssignmentCreateManyChildInputEnvelope
    connect?: ChildAssignmentWhereUniqueInput | ChildAssignmentWhereUniqueInput[]
  }

  export type ChildAssignmentUpdateManyWithoutChildNestedInput = {
    create?: XOR<ChildAssignmentCreateWithoutChildInput, ChildAssignmentUncheckedCreateWithoutChildInput> | ChildAssignmentCreateWithoutChildInput[] | ChildAssignmentUncheckedCreateWithoutChildInput[]
    connectOrCreate?: ChildAssignmentCreateOrConnectWithoutChildInput | ChildAssignmentCreateOrConnectWithoutChildInput[]
    upsert?: ChildAssignmentUpsertWithWhereUniqueWithoutChildInput | ChildAssignmentUpsertWithWhereUniqueWithoutChildInput[]
    createMany?: ChildAssignmentCreateManyChildInputEnvelope
    set?: ChildAssignmentWhereUniqueInput | ChildAssignmentWhereUniqueInput[]
    disconnect?: ChildAssignmentWhereUniqueInput | ChildAssignmentWhereUniqueInput[]
    delete?: ChildAssignmentWhereUniqueInput | ChildAssignmentWhereUniqueInput[]
    connect?: ChildAssignmentWhereUniqueInput | ChildAssignmentWhereUniqueInput[]
    update?: ChildAssignmentUpdateWithWhereUniqueWithoutChildInput | ChildAssignmentUpdateWithWhereUniqueWithoutChildInput[]
    updateMany?: ChildAssignmentUpdateManyWithWhereWithoutChildInput | ChildAssignmentUpdateManyWithWhereWithoutChildInput[]
    deleteMany?: ChildAssignmentScalarWhereInput | ChildAssignmentScalarWhereInput[]
  }

  export type ChildAssignmentUncheckedUpdateManyWithoutChildNestedInput = {
    create?: XOR<ChildAssignmentCreateWithoutChildInput, ChildAssignmentUncheckedCreateWithoutChildInput> | ChildAssignmentCreateWithoutChildInput[] | ChildAssignmentUncheckedCreateWithoutChildInput[]
    connectOrCreate?: ChildAssignmentCreateOrConnectWithoutChildInput | ChildAssignmentCreateOrConnectWithoutChildInput[]
    upsert?: ChildAssignmentUpsertWithWhereUniqueWithoutChildInput | ChildAssignmentUpsertWithWhereUniqueWithoutChildInput[]
    createMany?: ChildAssignmentCreateManyChildInputEnvelope
    set?: ChildAssignmentWhereUniqueInput | ChildAssignmentWhereUniqueInput[]
    disconnect?: ChildAssignmentWhereUniqueInput | ChildAssignmentWhereUniqueInput[]
    delete?: ChildAssignmentWhereUniqueInput | ChildAssignmentWhereUniqueInput[]
    connect?: ChildAssignmentWhereUniqueInput | ChildAssignmentWhereUniqueInput[]
    update?: ChildAssignmentUpdateWithWhereUniqueWithoutChildInput | ChildAssignmentUpdateWithWhereUniqueWithoutChildInput[]
    updateMany?: ChildAssignmentUpdateManyWithWhereWithoutChildInput | ChildAssignmentUpdateManyWithWhereWithoutChildInput[]
    deleteMany?: ChildAssignmentScalarWhereInput | ChildAssignmentScalarWhereInput[]
  }

  export type ChildUserCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ChildUserCreateWithoutAssignmentsInput, ChildUserUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ChildUserCreateOrConnectWithoutAssignmentsInput
    connect?: ChildUserWhereUniqueInput
  }

  export type EnumAssignmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssignmentStatus
  }

  export type ChildUserUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ChildUserCreateWithoutAssignmentsInput, ChildUserUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ChildUserCreateOrConnectWithoutAssignmentsInput
    upsert?: ChildUserUpsertWithoutAssignmentsInput
    connect?: ChildUserWhereUniqueInput
    update?: XOR<XOR<ChildUserUpdateToOneWithWhereWithoutAssignmentsInput, ChildUserUpdateWithoutAssignmentsInput>, ChildUserUncheckedUpdateWithoutAssignmentsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type booksCreateWithoutBook_detailsInput = {
    title: string
    authors?: string | null
    subject?: string | null
    code?: string | null
    edition?: string | null
    isbn?: string | null
    markup?: number | null
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cover_url?: string | null
    category?: string | null
    year?: string | null
    type?: string | null
    price_gbp?: Decimal | DecimalJsLike | number | string | null
    price_ugx?: Decimal | DecimalJsLike | number | string | null
    level?: string | null
    published_date?: Date | string | null
    format?: string | null
    has_digital_access?: boolean | null
    publisher?: string | null
    grade_year?: string | null
    author?: string | null
    category_lookup?: category_lookupCreateNestedOneWithoutBooksInput
    cart_items?: cart_itemsCreateNestedManyWithoutBooksInput
  }

  export type booksUncheckedCreateWithoutBook_detailsInput = {
    id?: number
    title: string
    authors?: string | null
    subject?: string | null
    code?: string | null
    edition?: string | null
    isbn?: string | null
    markup?: number | null
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cover_url?: string | null
    category?: string | null
    year?: string | null
    type?: string | null
    price_gbp?: Decimal | DecimalJsLike | number | string | null
    price_ugx?: Decimal | DecimalJsLike | number | string | null
    level?: string | null
    published_date?: Date | string | null
    format?: string | null
    has_digital_access?: boolean | null
    publisher?: string | null
    grade_year?: string | null
    category_id?: number | null
    author?: string | null
    cart_items?: cart_itemsUncheckedCreateNestedManyWithoutBooksInput
  }

  export type booksCreateOrConnectWithoutBook_detailsInput = {
    where: booksWhereUniqueInput
    create: XOR<booksCreateWithoutBook_detailsInput, booksUncheckedCreateWithoutBook_detailsInput>
  }

  export type booksUpsertWithoutBook_detailsInput = {
    update: XOR<booksUpdateWithoutBook_detailsInput, booksUncheckedUpdateWithoutBook_detailsInput>
    create: XOR<booksCreateWithoutBook_detailsInput, booksUncheckedCreateWithoutBook_detailsInput>
    where?: booksWhereInput
  }

  export type booksUpdateToOneWithWhereWithoutBook_detailsInput = {
    where?: booksWhereInput
    data: XOR<booksUpdateWithoutBook_detailsInput, booksUncheckedUpdateWithoutBook_detailsInput>
  }

  export type booksUpdateWithoutBook_detailsInput = {
    title?: StringFieldUpdateOperationsInput | string
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price_gbp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_ugx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    has_digital_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category_lookup?: category_lookupUpdateOneWithoutBooksNestedInput
    cart_items?: cart_itemsUpdateManyWithoutBooksNestedInput
  }

  export type booksUncheckedUpdateWithoutBook_detailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price_gbp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_ugx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    has_digital_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    cart_items?: cart_itemsUncheckedUpdateManyWithoutBooksNestedInput
  }

  export type book_detailsCreateWithoutBooksInput = {
    overview?: string | null
    features?: book_detailsCreatefeaturesInput | string[]
    contents?: book_detailsCreatecontentsInput | string[]
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type book_detailsUncheckedCreateWithoutBooksInput = {
    id?: number
    overview?: string | null
    features?: book_detailsCreatefeaturesInput | string[]
    contents?: book_detailsCreatecontentsInput | string[]
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type book_detailsCreateOrConnectWithoutBooksInput = {
    where: book_detailsWhereUniqueInput
    create: XOR<book_detailsCreateWithoutBooksInput, book_detailsUncheckedCreateWithoutBooksInput>
  }

  export type category_lookupCreateWithoutBooksInput = {
    category_name: string
  }

  export type category_lookupUncheckedCreateWithoutBooksInput = {
    id?: number
    category_name: string
  }

  export type category_lookupCreateOrConnectWithoutBooksInput = {
    where: category_lookupWhereUniqueInput
    create: XOR<category_lookupCreateWithoutBooksInput, category_lookupUncheckedCreateWithoutBooksInput>
  }

  export type cart_itemsCreateWithoutBooksInput = {
    user_id: number
    quantity?: number | null
    added_at?: Date | string | null
  }

  export type cart_itemsUncheckedCreateWithoutBooksInput = {
    id?: number
    user_id: number
    quantity?: number | null
    added_at?: Date | string | null
  }

  export type cart_itemsCreateOrConnectWithoutBooksInput = {
    where: cart_itemsWhereUniqueInput
    create: XOR<cart_itemsCreateWithoutBooksInput, cart_itemsUncheckedCreateWithoutBooksInput>
  }

  export type cart_itemsCreateManyBooksInputEnvelope = {
    data: cart_itemsCreateManyBooksInput | cart_itemsCreateManyBooksInput[]
    skipDuplicates?: boolean
  }

  export type book_detailsUpsertWithoutBooksInput = {
    update: XOR<book_detailsUpdateWithoutBooksInput, book_detailsUncheckedUpdateWithoutBooksInput>
    create: XOR<book_detailsCreateWithoutBooksInput, book_detailsUncheckedCreateWithoutBooksInput>
    where?: book_detailsWhereInput
  }

  export type book_detailsUpdateToOneWithWhereWithoutBooksInput = {
    where?: book_detailsWhereInput
    data: XOR<book_detailsUpdateWithoutBooksInput, book_detailsUncheckedUpdateWithoutBooksInput>
  }

  export type book_detailsUpdateWithoutBooksInput = {
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    features?: book_detailsUpdatefeaturesInput | string[]
    contents?: book_detailsUpdatecontentsInput | string[]
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type book_detailsUncheckedUpdateWithoutBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    features?: book_detailsUpdatefeaturesInput | string[]
    contents?: book_detailsUpdatecontentsInput | string[]
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type category_lookupUpsertWithoutBooksInput = {
    update: XOR<category_lookupUpdateWithoutBooksInput, category_lookupUncheckedUpdateWithoutBooksInput>
    create: XOR<category_lookupCreateWithoutBooksInput, category_lookupUncheckedCreateWithoutBooksInput>
    where?: category_lookupWhereInput
  }

  export type category_lookupUpdateToOneWithWhereWithoutBooksInput = {
    where?: category_lookupWhereInput
    data: XOR<category_lookupUpdateWithoutBooksInput, category_lookupUncheckedUpdateWithoutBooksInput>
  }

  export type category_lookupUpdateWithoutBooksInput = {
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type category_lookupUncheckedUpdateWithoutBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type cart_itemsUpsertWithWhereUniqueWithoutBooksInput = {
    where: cart_itemsWhereUniqueInput
    update: XOR<cart_itemsUpdateWithoutBooksInput, cart_itemsUncheckedUpdateWithoutBooksInput>
    create: XOR<cart_itemsCreateWithoutBooksInput, cart_itemsUncheckedCreateWithoutBooksInput>
  }

  export type cart_itemsUpdateWithWhereUniqueWithoutBooksInput = {
    where: cart_itemsWhereUniqueInput
    data: XOR<cart_itemsUpdateWithoutBooksInput, cart_itemsUncheckedUpdateWithoutBooksInput>
  }

  export type cart_itemsUpdateManyWithWhereWithoutBooksInput = {
    where: cart_itemsScalarWhereInput
    data: XOR<cart_itemsUpdateManyMutationInput, cart_itemsUncheckedUpdateManyWithoutBooksInput>
  }

  export type cart_itemsScalarWhereInput = {
    AND?: cart_itemsScalarWhereInput | cart_itemsScalarWhereInput[]
    OR?: cart_itemsScalarWhereInput[]
    NOT?: cart_itemsScalarWhereInput | cart_itemsScalarWhereInput[]
    id?: IntFilter<"cart_items"> | number
    user_id?: IntFilter<"cart_items"> | number
    book_isbn?: StringFilter<"cart_items"> | string
    quantity?: IntNullableFilter<"cart_items"> | number | null
    added_at?: DateTimeNullableFilter<"cart_items"> | Date | string | null
  }

  export type booksCreateWithoutCart_itemsInput = {
    title: string
    authors?: string | null
    subject?: string | null
    code?: string | null
    edition?: string | null
    isbn?: string | null
    markup?: number | null
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cover_url?: string | null
    category?: string | null
    year?: string | null
    type?: string | null
    price_gbp?: Decimal | DecimalJsLike | number | string | null
    price_ugx?: Decimal | DecimalJsLike | number | string | null
    level?: string | null
    published_date?: Date | string | null
    format?: string | null
    has_digital_access?: boolean | null
    publisher?: string | null
    grade_year?: string | null
    author?: string | null
    book_details?: book_detailsCreateNestedOneWithoutBooksInput
    category_lookup?: category_lookupCreateNestedOneWithoutBooksInput
  }

  export type booksUncheckedCreateWithoutCart_itemsInput = {
    id?: number
    title: string
    authors?: string | null
    subject?: string | null
    code?: string | null
    edition?: string | null
    isbn?: string | null
    markup?: number | null
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cover_url?: string | null
    category?: string | null
    year?: string | null
    type?: string | null
    price_gbp?: Decimal | DecimalJsLike | number | string | null
    price_ugx?: Decimal | DecimalJsLike | number | string | null
    level?: string | null
    published_date?: Date | string | null
    format?: string | null
    has_digital_access?: boolean | null
    publisher?: string | null
    grade_year?: string | null
    category_id?: number | null
    author?: string | null
    book_details?: book_detailsUncheckedCreateNestedOneWithoutBooksInput
  }

  export type booksCreateOrConnectWithoutCart_itemsInput = {
    where: booksWhereUniqueInput
    create: XOR<booksCreateWithoutCart_itemsInput, booksUncheckedCreateWithoutCart_itemsInput>
  }

  export type booksUpsertWithoutCart_itemsInput = {
    update: XOR<booksUpdateWithoutCart_itemsInput, booksUncheckedUpdateWithoutCart_itemsInput>
    create: XOR<booksCreateWithoutCart_itemsInput, booksUncheckedCreateWithoutCart_itemsInput>
    where?: booksWhereInput
  }

  export type booksUpdateToOneWithWhereWithoutCart_itemsInput = {
    where?: booksWhereInput
    data: XOR<booksUpdateWithoutCart_itemsInput, booksUncheckedUpdateWithoutCart_itemsInput>
  }

  export type booksUpdateWithoutCart_itemsInput = {
    title?: StringFieldUpdateOperationsInput | string
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price_gbp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_ugx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    has_digital_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    book_details?: book_detailsUpdateOneWithoutBooksNestedInput
    category_lookup?: category_lookupUpdateOneWithoutBooksNestedInput
  }

  export type booksUncheckedUpdateWithoutCart_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price_gbp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_ugx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    has_digital_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    book_details?: book_detailsUncheckedUpdateOneWithoutBooksNestedInput
  }

  export type booksCreateWithoutCategory_lookupInput = {
    title: string
    authors?: string | null
    subject?: string | null
    code?: string | null
    edition?: string | null
    isbn?: string | null
    markup?: number | null
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cover_url?: string | null
    category?: string | null
    year?: string | null
    type?: string | null
    price_gbp?: Decimal | DecimalJsLike | number | string | null
    price_ugx?: Decimal | DecimalJsLike | number | string | null
    level?: string | null
    published_date?: Date | string | null
    format?: string | null
    has_digital_access?: boolean | null
    publisher?: string | null
    grade_year?: string | null
    author?: string | null
    book_details?: book_detailsCreateNestedOneWithoutBooksInput
    cart_items?: cart_itemsCreateNestedManyWithoutBooksInput
  }

  export type booksUncheckedCreateWithoutCategory_lookupInput = {
    id?: number
    title: string
    authors?: string | null
    subject?: string | null
    code?: string | null
    edition?: string | null
    isbn?: string | null
    markup?: number | null
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cover_url?: string | null
    category?: string | null
    year?: string | null
    type?: string | null
    price_gbp?: Decimal | DecimalJsLike | number | string | null
    price_ugx?: Decimal | DecimalJsLike | number | string | null
    level?: string | null
    published_date?: Date | string | null
    format?: string | null
    has_digital_access?: boolean | null
    publisher?: string | null
    grade_year?: string | null
    author?: string | null
    book_details?: book_detailsUncheckedCreateNestedOneWithoutBooksInput
    cart_items?: cart_itemsUncheckedCreateNestedManyWithoutBooksInput
  }

  export type booksCreateOrConnectWithoutCategory_lookupInput = {
    where: booksWhereUniqueInput
    create: XOR<booksCreateWithoutCategory_lookupInput, booksUncheckedCreateWithoutCategory_lookupInput>
  }

  export type booksCreateManyCategory_lookupInputEnvelope = {
    data: booksCreateManyCategory_lookupInput | booksCreateManyCategory_lookupInput[]
    skipDuplicates?: boolean
  }

  export type booksUpsertWithWhereUniqueWithoutCategory_lookupInput = {
    where: booksWhereUniqueInput
    update: XOR<booksUpdateWithoutCategory_lookupInput, booksUncheckedUpdateWithoutCategory_lookupInput>
    create: XOR<booksCreateWithoutCategory_lookupInput, booksUncheckedCreateWithoutCategory_lookupInput>
  }

  export type booksUpdateWithWhereUniqueWithoutCategory_lookupInput = {
    where: booksWhereUniqueInput
    data: XOR<booksUpdateWithoutCategory_lookupInput, booksUncheckedUpdateWithoutCategory_lookupInput>
  }

  export type booksUpdateManyWithWhereWithoutCategory_lookupInput = {
    where: booksScalarWhereInput
    data: XOR<booksUpdateManyMutationInput, booksUncheckedUpdateManyWithoutCategory_lookupInput>
  }

  export type booksScalarWhereInput = {
    AND?: booksScalarWhereInput | booksScalarWhereInput[]
    OR?: booksScalarWhereInput[]
    NOT?: booksScalarWhereInput | booksScalarWhereInput[]
    id?: IntFilter<"books"> | number
    title?: StringFilter<"books"> | string
    authors?: StringNullableFilter<"books"> | string | null
    subject?: StringNullableFilter<"books"> | string | null
    code?: StringNullableFilter<"books"> | string | null
    edition?: StringNullableFilter<"books"> | string | null
    isbn?: StringNullableFilter<"books"> | string | null
    markup?: FloatNullableFilter<"books"> | number | null
    price?: FloatNullableFilter<"books"> | number | null
    createdAt?: DateTimeFilter<"books"> | Date | string
    updatedAt?: DateTimeNullableFilter<"books"> | Date | string | null
    cover_url?: StringNullableFilter<"books"> | string | null
    category?: StringNullableFilter<"books"> | string | null
    year?: StringNullableFilter<"books"> | string | null
    type?: StringNullableFilter<"books"> | string | null
    price_gbp?: DecimalNullableFilter<"books"> | Decimal | DecimalJsLike | number | string | null
    price_ugx?: DecimalNullableFilter<"books"> | Decimal | DecimalJsLike | number | string | null
    level?: StringNullableFilter<"books"> | string | null
    published_date?: DateTimeNullableFilter<"books"> | Date | string | null
    format?: StringNullableFilter<"books"> | string | null
    has_digital_access?: BoolNullableFilter<"books"> | boolean | null
    publisher?: StringNullableFilter<"books"> | string | null
    grade_year?: StringNullableFilter<"books"> | string | null
    category_id?: IntNullableFilter<"books"> | number | null
    author?: StringNullableFilter<"books"> | string | null
  }

  export type ChildAssignmentCreateWithoutChildInput = {
    id?: string
    subject: string
    accessCode: string
    providerUrl: string
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChildAssignmentUncheckedCreateWithoutChildInput = {
    id?: string
    subject: string
    accessCode: string
    providerUrl: string
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChildAssignmentCreateOrConnectWithoutChildInput = {
    where: ChildAssignmentWhereUniqueInput
    create: XOR<ChildAssignmentCreateWithoutChildInput, ChildAssignmentUncheckedCreateWithoutChildInput>
  }

  export type ChildAssignmentCreateManyChildInputEnvelope = {
    data: ChildAssignmentCreateManyChildInput | ChildAssignmentCreateManyChildInput[]
    skipDuplicates?: boolean
  }

  export type ChildAssignmentUpsertWithWhereUniqueWithoutChildInput = {
    where: ChildAssignmentWhereUniqueInput
    update: XOR<ChildAssignmentUpdateWithoutChildInput, ChildAssignmentUncheckedUpdateWithoutChildInput>
    create: XOR<ChildAssignmentCreateWithoutChildInput, ChildAssignmentUncheckedCreateWithoutChildInput>
  }

  export type ChildAssignmentUpdateWithWhereUniqueWithoutChildInput = {
    where: ChildAssignmentWhereUniqueInput
    data: XOR<ChildAssignmentUpdateWithoutChildInput, ChildAssignmentUncheckedUpdateWithoutChildInput>
  }

  export type ChildAssignmentUpdateManyWithWhereWithoutChildInput = {
    where: ChildAssignmentScalarWhereInput
    data: XOR<ChildAssignmentUpdateManyMutationInput, ChildAssignmentUncheckedUpdateManyWithoutChildInput>
  }

  export type ChildAssignmentScalarWhereInput = {
    AND?: ChildAssignmentScalarWhereInput | ChildAssignmentScalarWhereInput[]
    OR?: ChildAssignmentScalarWhereInput[]
    NOT?: ChildAssignmentScalarWhereInput | ChildAssignmentScalarWhereInput[]
    id?: StringFilter<"ChildAssignment"> | string
    childId?: StringFilter<"ChildAssignment"> | string
    subject?: StringFilter<"ChildAssignment"> | string
    accessCode?: StringFilter<"ChildAssignment"> | string
    providerUrl?: StringFilter<"ChildAssignment"> | string
    status?: EnumAssignmentStatusFilter<"ChildAssignment"> | $Enums.AssignmentStatus
    createdAt?: DateTimeFilter<"ChildAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"ChildAssignment"> | Date | string
  }

  export type ChildUserCreateWithoutAssignmentsInput = {
    id?: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChildUserUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChildUserCreateOrConnectWithoutAssignmentsInput = {
    where: ChildUserWhereUniqueInput
    create: XOR<ChildUserCreateWithoutAssignmentsInput, ChildUserUncheckedCreateWithoutAssignmentsInput>
  }

  export type ChildUserUpsertWithoutAssignmentsInput = {
    update: XOR<ChildUserUpdateWithoutAssignmentsInput, ChildUserUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ChildUserCreateWithoutAssignmentsInput, ChildUserUncheckedCreateWithoutAssignmentsInput>
    where?: ChildUserWhereInput
  }

  export type ChildUserUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ChildUserWhereInput
    data: XOR<ChildUserUpdateWithoutAssignmentsInput, ChildUserUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ChildUserUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildUserUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cart_itemsCreateManyBooksInput = {
    id?: number
    user_id: number
    quantity?: number | null
    added_at?: Date | string | null
  }

  export type cart_itemsUpdateWithoutBooksInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cart_itemsUncheckedUpdateWithoutBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cart_itemsUncheckedUpdateManyWithoutBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type booksCreateManyCategory_lookupInput = {
    id?: number
    title: string
    authors?: string | null
    subject?: string | null
    code?: string | null
    edition?: string | null
    isbn?: string | null
    markup?: number | null
    price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cover_url?: string | null
    category?: string | null
    year?: string | null
    type?: string | null
    price_gbp?: Decimal | DecimalJsLike | number | string | null
    price_ugx?: Decimal | DecimalJsLike | number | string | null
    level?: string | null
    published_date?: Date | string | null
    format?: string | null
    has_digital_access?: boolean | null
    publisher?: string | null
    grade_year?: string | null
    author?: string | null
  }

  export type booksUpdateWithoutCategory_lookupInput = {
    title?: StringFieldUpdateOperationsInput | string
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price_gbp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_ugx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    has_digital_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    book_details?: book_detailsUpdateOneWithoutBooksNestedInput
    cart_items?: cart_itemsUpdateManyWithoutBooksNestedInput
  }

  export type booksUncheckedUpdateWithoutCategory_lookupInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price_gbp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_ugx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    has_digital_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    book_details?: book_detailsUncheckedUpdateOneWithoutBooksNestedInput
    cart_items?: cart_itemsUncheckedUpdateManyWithoutBooksNestedInput
  }

  export type booksUncheckedUpdateManyWithoutCategory_lookupInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    edition?: NullableStringFieldUpdateOperationsInput | string | null
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price_gbp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_ugx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    format?: NullableStringFieldUpdateOperationsInput | string | null
    has_digital_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChildAssignmentCreateManyChildInput = {
    id?: string
    subject: string
    accessCode: string
    providerUrl: string
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChildAssignmentUpdateWithoutChildInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    providerUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildAssignmentUncheckedUpdateWithoutChildInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    providerUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildAssignmentUncheckedUpdateManyWithoutChildInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    providerUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}